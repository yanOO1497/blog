[{"title":"Canvas 开发经验记录","date":"2021-06-07T06:32:22.000Z","updated":"2021-06-12T10:38:30.367Z","content":"使用 Canvas 也有一段时间了，也算是 get 到了一点点开发过程中的小经验小总结，特此记录。\n\n在绘制一些重复图形时，可以利用 Path2D 来缓存已经绘制好的图形，实现快速的复制、移动、形变等等。\n\n使用示例：\n曲线、图表的循环模式，可以在绘制完曲线后，将缓存平移后再绘制，示例如下：（请注意，变量名都是根据实际用途取的，一些初始化等等没有记录在内，可以根据名字便知是什么，看看思想即可。）\n123456789101112131415161718192021222324const curveCache = new Path2D();curveCache.moveTo(0,0);curveCache.lineTo(100,100)// ... 此处省略一系列绘制操作// 计算整段曲线长度const w = endPoint.x - startPoint.x;// 计算需要循环绘制次数const loop = Math.ceil((viewWidth - endPoint.x) / w);const m = createMatrix();const curvePath = new Path2D();// ... 省略初始点绘制移动for (let i = 0; i &lt; loop; i++) &#123;    curvePath.moveTo(startPoint.x - w * i, startPoint.y);    m.translateSelf(-w, 0);    curvePath.lineTo(startPoint.x - w * i, endPoint.y);    // 按照一定的形变规则，添加到新的绘制存储内部    curvePath.addPath(this.curveCache, m);&#125;ctx.stroke(curvePath);\n\n\n当场景内绘制图形比较简单单一时，选中操作可以使用像素值对比来快速判断。\n\n12345678const imageData = ctx.getImageData(x, y, rectWidth);// 空白像素值const UINT8_COLOR_DEFAULT = Array(4 * PIXEL_RANGE * PIXEL_RANGE)    .fill(0)    .toString();if (imageData !== UINT8_COLOR_DEFAULT) &#123;    // TODO 点中像素&#125;\n\n… 未待完续\n","plink":"https://yanoo1497.github.io/post/2021-canvas-tips/"},{"title":"Canvas 绘制 iconfont 图标","date":"2021-06-07T06:32:22.000Z","updated":"2021-06-12T10:38:30.366Z","content":"\n获取到 iconfont 对应图标的 u16 字符，具体是 &amp;# + 字符，如下图的结果则是 &amp;#e7a0\n\n1const u16 = '&amp;#e7a0';\n\n\n获取实际绘制的文本字符\n\n1const icon = eval(('(\"' + u16).replace('&amp;#x', '\\\\u').replace(';', '') + '\")');\n\n\n在 canvas 上使用 iconfont 对应的字体绘制 icon\n\n123const ICON_FONT_NAME = 'iconfont'; // 字体名称按照实际使用的替换this.ctx.font = `12px $&#123;ICON_FONT_NAME&#125;`;this.ctx.fillText(icon, 10, 20);\n\n","plink":"https://yanoo1497.github.io/post/canvas-iconfont/"},{"title":"module.exports 与 exports 的区别（极简）","date":"2020-08-16T07:20:41.000Z","updated":"2021-06-12T10:38:29.396Z","content":"这个问题简单解释起来只有一句话: module.exports 是实际存储模块的对象，而 exports 只是存储对 module.exports 对象引用的变量。因而直接修改 exports 的并不会修改模块的导出信息。\n这些在官方文档内也有说明 https://nodejs.org/docs/latest-v9.x/api/modules.html\n代码示例：\n1234567891011121314151617181920212223242526272829exports.name = 'Alan';exports.test = function () &#123;  console.log('hi')&#125;;// 给导出的对象添加属性，直接这样就好了console.log(module) // &#123; exports: &#123; name: 'Alan', test: [Function] &#125; &#125;exports = &#123;  name: 'Bob',  add: function (a, b) &#123;    return a + b;  &#125;&#125;// 不过 ① exports 是一个引用，直接赋值给它，只是让这个变量等于另外一个引用console.log(exports) // &#123; name: 'Bob', add: [Function] &#125;// 并不会修改到导出的对象console.log(module) // &#123; exports: &#123; name: 'Alan', test: [Function] &#125; &#125;module.exports = &#123;  name: 'Bob',  add: function (a, b) &#123;    return a + b;  &#125;&#125;// ∵① 所以 只有通过 module.exports 才能真正修改到 exports 本身console.log(module) // &#123; exports: &#123; name: 'Bob', add: [Function] &#125; &#125;\n\n","plink":"https://yanoo1497.github.io/post/20-08-16-exports/"},{"title":"JS Tips 快速总结","date":"2020-05-24T07:20:41.000Z","updated":"2021-06-12T10:38:29.435Z","content":"\n知识点主要整理自 js-tips\n\n\n向数组插入元素几种情况的性能对比\n\n\n向数组结尾添加元素, 直接赋值 &gt; push &gt; concat  手机端：\n  1231. arr[arr.length] = 6; // 平均 5 632 856 ops/sec2. arr.push(6); // 慢35.64%3. arr2 = arr.concat([6]); // 慢62.67%\n\n  桌面端：\n  1231. arr[arr.length] = 6; // 平均42 345 449 ops/sec2. arr.push(6); // 慢34.66%3. arr2 = arr.concat([6]); // 慢85.79%\n\n向数组头部添加元素，concat &gt; unshift\n  手机端：\n  121. [0].concat(arr); // 平均4 972 622 ops/sec2. arr.unshift(0); // 慢64.70%\n\n  桌面端：\n  121. [0].concat(arr); // 平均6 032 573 ops/sec2. arr.unshift(0); // 慢78.65%\n\n\n\n原文：https://www.jstips.co/zh_cn/javascript/insert-item-inside-an-array/\n","plink":"https://yanoo1497.github.io/post/js -tips/"},{"title":"JS 数字字符串排序优化","date":"2020-05-24T07:20:41.000Z","updated":"2021-06-12T10:38:30.365Z","content":"JS 内的数据排序是非常常见的需求，大部分情况下的字符串比较会使用直接对比、localCompare 等方式比较，但是在数据量大的情况下往往不理想。\n使用 Intl.Collator 构建对比函数将会获得更加优异的性能效果。\n12345const a = ['Offenbach', 'Österreich', 'Odenwald'];const collator = new Intl.Collator('de-u-co-phonebk');a.sort(collator.compare);console.log(a.join(', '));// → \"Odenwald, Österreich, Offenbach\"\n\n","plink":"https://yanoo1497.github.io/post/quick-sort/"},{"title":"安装 node C++ 模块的常见问题\"node.lib:fatal error LNK1127\"","date":"2020-05-24T07:20:41.000Z","updated":"2021-06-12T10:38:30.360Z","content":"“node.lib:fatal error LNK1127”参考：https://blog.csdn.net/qq_33826977/article/details/78645665\n在需要编译的 npm 模块包内执行以下命令：\n123node-gyp clearnode-gyp configurenode-gyp build\n\n直接 install 该 npm 包失败在安装命令后添加 --ignore-script 即可跳过 c++ 库的编译过程，直接下载原包，在这之后需要自行对该 npm 包进行编译。\n","plink":"https://yanoo1497.github.io/post/20-08-26-nodegyp/"},{"title":"一些技术原则","date":"2020-05-24T07:20:41.000Z","updated":"2021-06-12T10:38:29.437Z","content":"做事的方法有两个极端：一是先磨刀，再砍柴；二是不磨刀，凑合砍。我们对学习方法的认识，一直在两个极端中摇摆。现在的时代更常采用第二种方式：用什么学什么，解决问题即可。其实这种做法有值得推崇的地方：灵活快速，但是务必要记住在解决了眼下的问题之后，一定要再去把刀磨了。\n可以很负责任的说，90%以上的使用问题，在官方文档上都有详细的、反复的描述，但是多数人还是凭自己的理解在做，每天都要重复别人踩过的坑。\n越早坚持写比如 csdn 或其他博客平台、做好自己日常知识管理的人，个人影响力就会越早得到放大。其中的原因我们都明白，只有某个问题彻底搞懂了的时候，自己才能把它自圆其说得写出来。经验的输出过程，是一个复利的过程，同时也是给工作中的学习画上一个完整的闭环。\n","plink":"https://yanoo1497.github.io/post/tips/"},{"title":"防抖节流函数实现","date":"2020-04-11T01:20:41.000Z","updated":"2021-06-12T10:38:29.438Z","content":"\n参考文章\n\n深入浅出防抖函数 debounce\nJavaScript专题之跟着underscore学防抖\n什么是防抖和节流？有什么区别？如何实现？\n别只掌握基础的防抖和节流了\n\n\n在前端开发中会遇到一些频繁的事件触发，比如：\n1234window 的 resize、scrollmousedown、mousemovekeyup、keydowninput\n\n这些处理函数如果在没有任何处理措施的情况下，会非常频繁的触发事件，而事件处理的逻辑如果较为复杂大概率上回造成页面卡顿现象。在这些事件的处理上，合理的使用防抖、节流函数是提高性能的不二选择。\n防抖函数（debounce）网上查到的概念也会有很多种，这里列举了不同的描述帮助理解：\n\n触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。\n某个函数在某段时间内，无论触发了多少次回调，都只执行最后一次。\n指定时间内，方法只能执行一次。而这个时间的计算，是从最后一次触发监听事件开始算起。\n一般表现为，在一段连续触发的事件中，最终会转化为一次方法执行，就像防止抖动一样，你做一个事，防止你手抖不小心重复干了。\n\n一些常见的实现高程中的经典代码123456function throttle(method, ...arg) &#123;    clearTimeout(method.tId);    method.tId = setTimeout(function () &#123;        method.call(...arg);    &#125;, 100)&#125;\n\n简单的利用 requestAnimationFrame 实现的防抖函数1234567function debounce(func) &#123;    var t;    return function () &#123;        t &amp;&amp; cancelAnimationFrame(t);        t = requestAnimationFrame(func);    &#125;&#125;\n\n防抖函数的工厂函数普通版123456789101112function debounce(func, wait) &#123;    var timeout;    return function (...args) &#123;        var context = this;        clearTimeout(timeout)        timeout = setTimeout(function()&#123;            func.apply(context, ...args)        &#125;, wait);    &#125;&#125;\n\n加强版123456789101112131415161718192021222324252627282930313233343536373839404142/** * 防抖函数 * @param &#123;Function&#125; fn - 实际要执行的函数 * @param &#123;Number&#125; wait - 规定延迟执行时间间隔，单位毫秒，初始化 16.7 ms（一帧） * @param &#123;Boolean&#125; immediate - 是否立即执行，true 为立即执行，立即执行指触发监听事件是先执行 * @return &#123;Function&#125; 经过防抖处理后的要执行的函数 */function debounce(fn, wait = 16.7, immediate = false) &#123;    if (typeof fn !== 'function') &#123;        throw new Error('debounce 的第一个参数请传入函数');        return;    &#125;    let timerId = null; // 记录定时器 id    // 防抖后的执行函数    function debounced(...args) &#123;        timerId &amp;&amp; clearTimeout(timerId);        // 如果是立即执行        if (immediate) &#123;            // 如果已经过了规定时间，则执行函数 或 第一次触发监听事件            !timerId &amp;&amp; fn.apply(this, args);            // 规定时间后情况定时器 id，表明到达了规定时间            timerId = setTimeout(() =&gt; &#123;                timerId = null;            &#125;, wait);        &#125; else &#123; // 延后执行            // 只有到达了规定时间后才会执行 fn 函数            timerId = setTimeout(() =&gt; &#123;                fn.apply(this, args);                timerId = null;            &#125;, wait);        &#125;    &#125;    // 手动取消该次设定的防抖时间，取消后当成是“第一次触发”一样    function cancel() &#123;        clearTimeout(timerId);        timerId = null;    &#125;    debounced.cancel = cancel;    return debounced;&#125;\n\n实现一些细节点\n间隔一段时间触发一次不一定要用 setTimeout, setTimeout 的时间间隔不可靠，可以使用具体时间戳自己计算间隔；\n如果要设计成通用工具函数，封装成工厂函数更加合适，需要注意 this 指向问题；\n\n应用场景：主要应用于对首次调用没有明确需要执行，但对最后一次调用要求较高的场景。例如：\n\nsearch 搜索联想，用户在不断输入值时，用防抖来节约请求资源。\nwindow 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次\n\n节流函数（throttle）这里列举了不同的描述帮助理解\n\n规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次（单位时间内的第一次）生效。\n可以保证第一次调用的一定会被执行，但无法保证最后一次调用的有效。\n高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率；\n指定时间内，方法只能执行一次。而这个时间的计算，是从上次执行方法开始算起。\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 节流函数 * @param &#123;Function&#125; fn - 实际要执行的函数，对其进行节流处理 * @param &#123;Number&#125; wait - 规定的执行时间间隔，单位毫秒，初始化 16.7 ms（一帧） * @param &#123;Object&#125; option - 用于设置节流的函数的触发时机， *                        - 默认是 &#123;leading: true, trailing: true&#125;，表示第一次触发监听事件马上执行，停止后最后也执行一次 *                        - leading 为 false 时，表示第一次触发不马上执行 *                        - trailing 为 false 时，表示最后停止触发后不执行 * @return &#123;Function&#125; 返回经过节流处理后的函数 */function throttle(fn, wait = 16.7, option = &#123;&#125;) &#123;    if (typeof fn !== 'function') &#123;        throw new Error('throttle 的第一个参数请传入函数');        return;    &#125;    let timerId = null; // 用于记录定时器的 id    let lastTime = 0; // 上次触发 fn 的时间戳    option = Object.assign(&#123;        leading: true,        trailing: true,    &#125;, option); // 初始化默认值    if (option.leading === false &amp;&amp; option.trailing === false) &#123;        throw new Error('option 的 leading 和 trailing 不能同时为 false');        return;    &#125;    // 节流后的执行函数    function throttled(...args) &#123;        let now = +new Date(); // 获取当前时间        // 如果没有上次触发执行时间（即第一次运行），以及 leading 设置为 false        !lastTime &amp;&amp; option.leading === false &amp;&amp; (lastTime = now);        // 距离到达规定的 wait 时间剩余时间        let remainingTime = wait - (now - lastTime);        // 条件①：如果到达了规定的间隔时间或用户自己设定了系统时间导致的不合理时间差，则立刻执行一次触发函数        if (remainingTime &lt;= 0 || remainingTime &gt; wait) &#123;            fn.apply(this, args);            lastTime = now;            if (timerId) &#123;                clearTimeout(timerId);                timerId = null;            &#125;            // 条件②：如果未达到规定时间，以及要求停止后延迟执行（trailing=false）        &#125; else if(!timerId &amp;&amp; option.trailing !== false) &#123;            timerId = setTimeout(() =&gt; &#123;                timerId = null;                fn.apply(this, args);                lastTime = option.leading === false ? 0 : +new Date();            &#125;, remainingTime);        &#125;    &#125;    // 手动提前终止节流时间，恢复初始状态    function cancel() &#123;        clearTimeout(timerId);        timerId = null;        lastTime = 0;    &#125;    throttled.cancel = cancel;    return throttled;&#125;\n\nthrottle 的选项配置说明\n在 {leading: true, trailing: true} 下，为大多数正常需求所用。在这种情况下，条件①只- 有在第一次触发，以及后续超过规定间隔时间后的第一次触发，才会走到该流程下；其余都是在条件②下触发fn。\n在 {leading: false} 下，都是在条件②下触发fn，走不到条件①下的。\n在 {trailing: false} 下，都是在条件①下触发fn，走不到条件②下的。\n\n应用场景主要应用于对最后一次调用没有明确需要执行，但对首次调用要求较高的场景。\n例如：表单提交按钮要避免用户多次点击发送多次消息。\n防抖节流在实际应用中的差异可以观察 http://demo.nimius.net/debounce_throttle/ 体验，不过这个只是最基本版本的防抖节流差异，实际上防抖节流函数可以设计成实际应用中需要的样子。如果只是简单场景中的使用，只需要写成最基础的版本即可。\n\n","plink":"https://yanoo1497.github.io/post/2020-4-11-debounce-throttle/"},{"title":"编写一个函数计算多个数组的交集","date":"2020-04-08T01:20:41.000Z","updated":"2021-06-12T10:38:29.434Z","content":"1234567891011function intersection(...args) &#123;    if (args.length === 0) &#123;        return []    &#125;    if (args.length === 1) &#123;        return args[0]    &#125;    return [...new Set(args.reduce((result, arg) =&gt; &#123;        return result.filter(item =&gt; arg.includes(item))    &#125;))]&#125;;\n\n","plink":"https://yanoo1497.github.io/post/intersect/"},{"title":"Git 常用操作以及相关文章记录（自检清单）","date":"2020-04-02T07:20:41.000Z","updated":"2021-06-12T10:38:29.430Z","content":"仅以此文，记录我在工作中经常遇到的一些 Git 使用上的问题以及对应的解决方案，初学者也可以把它当做一份自检清单，当然特别基础的切分支啥的就不会说啦。因为目前自己使用的 Git 工具是 smartGit 所以列举的一些解决方案是使用 smartGit 的操作界面。 smartGit 的安装可以参考 这篇文章。\n常用命令\n如何找回已被删除的本地分支代码\n1234git reflog// 查看 git 日志记录（使用上下键可翻页），找到被删除分支的最后一个 commit 值// 新建分支，执行以下命令git rest --hard &lt;commit&gt;\n\n如何拉取其他人的 PR 分支到本地\n1git fetch origin pull/xxx/head:pr（pr == 名字）\n\n或者使用 vscode 的 pull request 插件亦可\n\n\n一些链接关于 git 换行符设置\n初学者需要了解的其他 git 使用点rebase，reset，cheery pick, add remote、、、\n","plink":"https://yanoo1497.github.io/post/git/"},{"title":"《JavaScript 忍者秘籍》读书笔记","date":"2020-04-02T07:20:41.000Z","updated":"2021-06-12T10:38:29.432Z","content":"\n清明假期两天刷完的一本书，干货挺多的，值得观看。不过比较后面几个Dom、浏览器兼容的章节就没怎么看，重点都在中间的部分，尤其是关于函数、生成器和原型对象部分讲解的比较精彩，配图细致。以下内容是当天看完整理出来的稍微改动的书摘，记录的是我看时比较有收获的点作为记录，推荐大家自行观看原文。微信读书原文链接\n\n页面生命周期思维导图：\n客户端Web应用的执行分为两个阶段\n\n页面构建阶段：页面构建代码是用于创建DOM的，而全局JavaScript代码是遇到script节点时执行的。在这个执行过程中，JavaScript代码能够以任意程度改变当前的DOM，并且注册事件处理器。\n\n事件处理——在同一时刻，只能处理多个不同事件中的一个，处理顺序是事件生成的顺序。事件处理阶段大量依赖事件队列，所有的事件都以其出现的顺序存储在事件队列中。事件循环会检查实践队列的队头，如果检测到了一个事件，那么相应的事件处理器就会被调用。\n\n\n关于函数需要有的一个认知：函数是一等公民（一级对象），JS 是函数式编程的语言。\n匿名立即执行函数1(function() &#123;&#125;)()\n\n为什么匿名自执行函数需要 （） 包裹函数表达式被包裹在一对括号内其原因是纯语法层面的。\nJavaScript解析器必须能够轻易区分函数声明和函数表达式之间的区别。如果去掉包裹函数表达式的括号，把立即调用作为一个独立语句function() {}(3), JavaScript开始解析时便会结束，因为这个独立语句以function开头，那么解析器就会认为它在处理一个函数声明。每个函数声明必须有一个名字（然而这里并没有指定名字），所以程序执行到这里会报错。为了避免错误，函数表达式要放在括号内，为JavaScript解析器指明它正在处理一个函数表达式而不是语句。\n还有一种相对简单的替代方案 (function(){}(3)) 也能达到相同目标（然而这种方案有些奇怪，故不常使用）。把立即函数的定义和调用都放在括号内，同样可以为JavaScript解析器指明它正在处理函数表达式。在JavaScript库中会经常见到这几种形式：\n1234+function()&#123;&#125;()-function()&#123;&#125;()!function()&#123;&#125;()~function()&#123;&#125;()\n\n不同于用加括号的方式区分函数表达式和函数声明，这里我们使用一元操作符+、-、！和~。这种做法也是用于向JavaScript引擎指明它处理的是表达式，而不是语句。\n函数参数 arguments定义arguments 参数是传递给函数的所有参数集合。无论是否有明确定义对应的形参，通过它我们都可以访问到函数的所有参数。借此可以实现原生 JavaScript 并不支持的函数重载特性，而且可以实现接收参数数量可变的可变函数。\n注意：arguments 对象仅是一个类数组的结构，避免把arguments 参数当作_数组_。你可能会被它的用法误导，毕竟它有 length 属性，而且可以通过数组下标的方式访问到每一个元素。但它并非 JavaScript 数组，如果你尝试在 arguments 对象上使用数组的方法（例如sort方法），会发现最终会报错。\n在大多数情况下可以使用剩余参数（rest parameter）来代替arguments 参数。剩余参数是真正的 Array 实例，可以在它上面直接使用所有的数组方法。\narguments 与形参变量是相关联的在非严格模式下，arguments 对象是函数参数的别名，修改 arguments 对象会修改函数实参，可以通过严格模式避免修改函数实参。\n函数的调用1. 作为函数直接被调用当以这种方式调用时，函数上下文（this 关键字的值）有两种可能性：在非严格模式下，它将是全局上下文（window 对象），而在严格模式下，它将是 undefined。\n2. 作为对象的方法被调用当函数作为某个对象的方法被调用时，该对象会成为函数的上下文，并且在函数内部可以通过参数 this 访问到调用对象。\n3. 作为构造函数使用 new 关键字调用使用关键字 new 调用函数会触发以下几个动作。\n\n1．创建一个新的空对象。\n2．该对象作为 this 参数传递给构造函数，从而成为构造函数的函数上下文。\n3．新构造的对象作为 new 运算符的返回值\n\n构造函数的目的是创建一个新对象，并进行初始化设置，然后将其作为构造函数的返回值。任何有悖于这两点的情况都不适合作为构造函数。\n\n注意：如果构造函数返回一个对象，则该对象将作为整个表达式的值返回，而传入构造函数的 this 将被丢弃。但是，如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象。\n\n构造函数的目的是根据初始条件对函数调用创建的新对象进行初始化。\n不同调用方式的区别不同类型函数调用之间的主要区别在于：最终作为函数上下文（可以通过 this 参数隐式引用到）传递给执行函数的对象不同。\n修改函数上下文对象的方式使用现成方法apply,call,bind\napply 和 call 之间唯一的不同之处在于如何传递参数。在使用 apply的情况下，我们使用参数数组；在使用 call 的情况下，我们则在函数上下文之后依次列出调用参数。\n所有函数均可访问 bind 方法，可以创建并返回一个新函数，并绑定在传入的对象上。\n\n注意：如果在事件绑定时使用了 bind 过的函数，解绑时不能使用原函数解绑。\n\n使用箭头函数箭头函数没有单独的 this 值，this 在箭头函数创建时确定。\n闭包和作用域闭包是纯函数式编程语言的特性之一\nJS 的代码有两种类型：\n\n全局代码，在所有函数外部定义。\n函数代码，位于函数内部。\n\nJavaScript引擎执行代码时，每一条语句都处于特定的执行上下文中。既然具有两种类型的代码，那么就有两种执行上下文：全局执行上下文和函数执行上下文。\n二者最重要的差别是：全局执行上下文只有一个，当 JavaScript 程序开始执行时就已经创建了全局上下文；而函数执行上下文是在每次调用函数时，就会创建一个新的。\nJS 在某个特定的时刻只能执行特定的代码。一旦发生函数调用，当前的执行上下文必须停止执行，并创建新的函数执行上下文来执行函数。当函数执行完成后，将函数执行上下文销毁，并重新回到发生调用时的执行上下文中。所以需要跟踪执行上下文——正在执行的上下文以及正在等待的上下文。最简单的跟踪方法是使用执行上下文栈（或称为调用栈）\n词法环境是 JavaScript 作用域的内部实现机制，人们通常称为作用域(scopes)。\nvar 声明的变量实际上总是在距离最近的函数内或全局词法环境中注册的，不关注块级作用域。\nvar 是在距离最近的函数或全局词法环境中定义变量，与var不同的是，let 和 const 更加直接。let 和 const 直接在最近的词法环境中定义变量（可以是在块级作用域内、循环内、函数内或全局环境内）。我们可以使用 let 和 const 定义块级别、函数级别、全局级别的变量。\n生成器和 promise生成器内部实现通过调用生成器得到的迭代器，暴露出一个 next 方法能让我们向迭代器请求一个新值。next 方法返回一个携带着生成值的对象，而该对象中包含的另一个属性done也向我们指示了生成器是否还会追加生成值。在生成器生成（或让渡）了一个值后，生成器会挂起执行并等待下一个请求的到来。在某种方面来说，生成器的工作更像是一个小程序，一个在状态中运动的状态机。\n\n挂起开始 —— 创建了一个生成器后，它最先以这种状态开始。其中的任何代码都未执行。\n执行 —— 生成器中的代码已执行。执行要么是刚开始，要么是从上次挂起的时候继续的。当生成器对应的迭代器调用了 next 方法，并且当前存在可执行的代码时，生成器都会转移到这个状态。\n挂起让渡 —— 当生成器在执行过程中遇到了一个 yield 表达式，它会创建一个包含着返回值的新对象，随后再挂起执行。生成器在这个状态暂停并等待继续执行。\n完成 —— 在生成器执行期间，如果代码执行到 return 语句或者全部代码执行完毕，生成器就进入该状态。\n\n在迭代器上使用 yield* 操作符，程序会跳转到另外一个生成器上执行。\n使用迭代器生成 ID 序列12345678const IDGenerator = (function*() &#123;    let id = 0;    while(true) &#123;        yield ++id;    &#125;&#125;)();const id_1 = IDGenerator.next(); // 1const id_2 = IDGenerator.next(); // 2\n\n优点：使用方式简单，id 值在闭包里面不容易被外部修改到\nasync 函数函数和生成器的差异函数和生成器之间的关键不同在于，标准函数仅仅会被重复调用，每次调用都会创建一个新的执行环境上下文。相比之下，生成器的执行环境上下文则会暂时挂起并在将来恢复。\n对象与原型关于原型的其他内容，可以参考之前的：JS 原型链速记总结\n在 JavaScript 中，对象的原型属性是内置属性（使用标记[[prototype]]），无法直接访问。可以使用内置的方法 Object.setPrototypeOf 需要传入两个对象作为参数，并将第二个对象设置为第一个对象的原型。\n利用闭包创建对象私有变量在构造函数内部定义方法，使得我们可以模仿私有对象变量。如果我们需要私有对象，在构造函数内指定方法是唯一的解决方案。\n12345678910function Person() &#123;    this.test = function () &#123;        console.log('this test');    &#125;&#125;Person.prototype.test = function () &#123;    console.log('prototype test');&#125;const person = new Person();person.test(); // this test\n\n在构造函数内部，关键字 this 指向新创建的对象，所以在构造器内添加的属性直接在新的实例上，person 实例在调用 test 方法时不需要查找原型链，因而输出的时 this 上绑定方法的结果。\n因而一些公用方法的定义并不推荐直接绑定在 this 上，会使每个实例对象都挂上一个相同的方法，更好的方式是将其绑定在构造函数的 prototype 上，充分利用 js 的继承。但是这个特性也可以利用来生成私有方法。\n利用 constructor 引用创建新对象我们可以使用 constructor 属性验证实例的原始类型（与操作符instanceof 非常类似）\n由于 constructor 属性仅仅是原始构造函数的引用，因此我们可以使用该属性创建新的实例对象，例如：\n1const test = new interface.constructor();\n\n利用原型实现继承12345678910function Person() &#123;&#125;;function Ninjia() &#123;&#125;;// 1. 所有继承函数的原型将实时更新// Ninja.prototype = Person.prototype;// const ninja = new Ninja();// 2. // Ninja.prototype = new Person();// const ninjia = new Ninjia();\n\n\n直接使用 Person 的原型对象作为 Ninja 的原型，如 Ninja.prototype = Person.prototype。这样做会导致在 Person 原型上所发生的所有变化都被同步到 Ninja 原型上（Person 原型与 Ninja 原型是同一个对象），一定会有不良的副作用。这种原型实现继承的方式的副作用好的一面是，所有继承函数的原型将实时更新。从原型继承的对象总是可以访问当前原型属性。\n\n将 Person 的实例对象作为 Ninja 的原型\n\n\n带来的问题：\n通过设置 Person 实例对象作为 Ninja 构造器的原型时，我们已经丢失了 Ninja 与 Ninja 初始原型之间的关联，无法再通过 constructor 获取 Ninja 的引用。如果其他地方使用了 constructor 属性检测一个对象是否由某一个函数创建，就会产生错误。\n解决方式：\n使用 Object.defineProperty 方法在 Ninja.prototype 对象上增加新的 constructor 属性。\n\nEs6 class由于每个类库对类的实现都有不同的方式，ECMAScript委员会对“模拟”基于类的继承语法进行标准化。注意是“模拟”。虽然现在我们可以在JavaScript中使用关键字class，但其底层的实现仍然是基于原型继承！class只是语法糖，使得在JavaScript模拟类的代码更为简洁罢了。\n关于静态属性方法：\n我们只需要记住通过函数来实现类。由于静态方法是类级别的方法，所以可以利用第一类型对象，在构造函数上添加方法\n关于 instanceof定义：检查右边的函数原型是否存在于操作符左边的对象的原型链上\n在JavaScript中，操作符 instanceof 将会查找整个原型链，尽管经常用来确定一个实例是否是由一个特定的构造函数创建的，但是并不完全准确。\n控制对象的访问定义 getter 和 setter\n通过对象字面量定义，或在ES6的class中定义。\n通过使用内置的Object.defineProperty方法。\n\n通过 代理（proxy）代理（proxy）是我们通过代理控制对另一个对象的访问。通过代理可以定义当对象发生交互时可执行的自定义行为——如读取或设置属性值，或调用方法。可以将代理理解为通用化的setter与getter，区别是每个setter与getter仅能控制单个对象属性，而代理可用于对象交互的通用处理，包括调用对象的方法。过去使用setter与getter处理日志记录、数据校验、计算属性等操作，均可使用代理对它们进行处理。\n实际应用\n\nJavaScript不支持数组负索引，但是，我们可以使用代理进行模拟\n属性修改检验，默认值写入\n\n尽管使用代理可以创造性地控制对象的访问，但是大量的控制操作将带来性能问题。可以在多性能不敏感的程序里使用代理，但是若多次执行代码时仍然要小心谨慎。像往常一样，我们建议你彻底地测试代码的性能。\n集合原型继承属性以及key仅支持字符串，所以通常不能使用对象作为map。由于这种限制，ECMAScript委员会定义了一个全新类型：Map。\n因为map是集合，可以使用for of循环遍历 map,并且可以确保遍历的顺序与插入的顺序一致。\n正则表达式当正则表达式在开发环境是明确的，推荐优先使用字面量语法；当需要在运行时动态创建字符串来构建正则表达式时，则使用构造函数的方式。优先使用字面量语法，原因之一是反斜线在正则表达式中发挥了重要的作用。但是反斜线也用于转义字符，因此，对于反斜线本身则需要使用双反斜线来标识\\。这使得本来就很奇怪的正则表达式表示字符串时看起来更加诡异。\n反向引用可引用正则中定义的捕获\n处理正则的基础流程处理正则表达式经历多个阶段，理解每个阶段的处理有助于使用正则表达式优化JavaScript代码。其中两个主要的阶段是编译和执行。编译阶段发生在正则表达式被创建的时期。执行阶段发生在使用编译之后的正则表达式进行匹配字符串的时期。\n编译每个正则表达式都有一个独特的对象表示：每次创建一个正则表达式（也被编译）都会创建一个新的正则表达式对象。这与原始类型（如string、number等）不同，因为每个正则对象永远是独一无二的。\n一些使用 Tips\n\n推荐使用预创建和预编译的正则表达式，以便以后重复使用，这对性能的提升不容忽视。几乎所有复杂的正则表达式都能从中受益。\n\n可以在全局匹配中使用正则表达式的exec方法，每次调用都可以返回下一个匹配的结果，这样可以使用缓存来访问到所有匹配对象。\n\n圆括号有两项职责：不仅定义分组，而且还可以指定捕获。说明有一组括号不应该产生捕获，正则表达式语法可以在起始圆括号之后使用符号？:。这就是所谓的被动子表达式（passive subexpression）\n  注意：尽可能在我们的正则表达式中，在不需要捕获的情况下，使用非捕获分组代替捕获，表达式引擎不需要记忆和返回捕获结果，这可以减少很多工作。\n\n\n其他\nreplace 最重要的特性是不仅支持替换值，而且支持替换函数作为参数。当第2个参数是函数时，对每一个所匹配到的值都会调用一遍（全局匹配会返回匹配到的全部内容）\n代码模块化小的、组织良好的代码远比庞大的代码更容易理解、更易于维护。因此，很自然，优化程序的结构和组织的方式，就是把它们分成小的、耦合相对松散的片段，这些片段称为模块。\n模块是比对象和函数更大的代码单元，使用模块可以将程序进行归类。创建模块时，我们应该努力形成一致的抽象和封装。这样有益于思考应用程序，当使用模块的功能时，可以避免被琐碎细节干扰。\nJavaScript ES6 之前，只有两种作用域：全局作用域和函数作用域。没有介于两者之间的作用域，没有命名空间或模块可以将功能进行分组。为了编写模块化代码，JavaScript开发者们不得不创造性地使用JavaScript现有的语法特性。\n当决定使用哪种模块系统时，我们需要谨记，每个模块系统至少应该能够执行以下操作：\n\n定义模块接口，通过接口可以调用模块的功能。\n隐藏模块的内部实现，使模块的使用者无需关注模块内部的实现细节。同时，隐藏模块的内部实现，避免有可能产生的副作用和对bug的不必要修改。\n\nAMD 和 CommonJSAMD 和 CommonJS 是两个相互竞争的标准，均可以定义JavaScript模块。除了语法和原理的区别之外，主要的区别是AMD的设计理念是明确基于浏览器，而CommonJS的设计是面向通用JavaScript环境（如Node.js服务端），而不局限于浏览器。\nAMD 优点\n自动处理依赖，我们无需考虑模块引入的顺序。\n异步加载模块，避免阻塞。\n在同一个文件中可以定义多个模块。\n\n文件同步加载，可以访问模块公共接口。这是CommonJS在服务端更流行的原因，模块加载相对更快，只需要读取文件系统，而在客户端则必须从远程服务器下载文件，同步加载通常意味着阻塞。\nCommonJS 优势\n语法简单。只需定义module.exports属性，剩下的模块代码与标准JavaScript无差异。引用模块的方法也很简单，只需要使用require函数。\nCommonJS 是 Node.js 默认的模块格式，所以我们可以使用npm上成千上万的包。\n\nEs6 模块集合两大模块系统优点\n\n与CommonJS类似，ES6模块语法相对简单，并且基于文件（每个文件就是一个模块）。\n与AMD类似，ES6模块支持异步模块加载。\n\nES6模块的主要思想是必须显式地使用标识符导出模块，才能从外部访问模块。其他标识符，甚至在最顶级作用域中定义的（可能是标准JavaScript中的全局作用域）标识符，只能在模块内使用。这一点是受到CommonJS启发。为了提供这个功能，ES6引入两个关键字。● export——从模块外部指定标识符。● import——导入模块标识符。\n需要时，可以使用 as 关键字同时重命名export和import。\nJS 的 DOM 操作\n元素的style属性中的任何值，都优先于样式表继承的值（即使样式表规则使用！important的注释）\n\n多个单词的CSS样式名称作为属性名时，会转换为驼峰格式\n\n一个元素的计算后样式（computed style）都是应用在该元素上的所有样式的组合，这些样式包括样式表、元素的style特性，以及脚本对style做的各种操作。\n\n与元素样式对象不同，getPropertyValue方法接收CSS属性名称（例如font-size和background-color），而不是这些名称的驼峰式版本\n\n并非所有的数值都代表像素,有很多style的属性值表示的不是像素尺寸。z-index, font-weight, opacity, zoom, line-height对于这些（以及其他我们所能想到的）属性&gt;同样，在尝试获取style特性的像素值时，应该使用 parseFloat 方法进行转换操作，以确保在任何情况下获取的值都是预期值。\n\noffsetHeight 和 offsetWidth都提供了这样的功能：可以相当可靠地访问实际元素的高度和宽度。但是请注意，这两个属性的值都包含了元素的padding值。\n\n避免布局抖动的一种方法，就是使用不会导致浏览器重排的方式编写代码\n\n\n事件事件循环不仅仅包含事件队列，而是具有至少两个队列，除了事件，还要保持浏览器执行的其他操作。这些操作被称为任务，并且分为两类：宏任务（或通常称为任务）和微任务。\n宏任务宏任务的例子很多，包括创建主文档对象、解析HTML、执行主线（或全局）JavaScript代码，更改当前URL以及各种事件，如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，宏任务代表一个个离散的、独立工作单元。运行完任务后，浏览器可以继续其他调度，如重新渲染页面的UI或执行垃圾回收。\n微任务而微任务是更小的任务。微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。微任务的案例包括promise回调函数、DOM发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使应用程序的状态不连续。\n事件循环的实现至少应该含有一个用于宏任务的队列和至少一个用于微任务的队列。大部分的实现通常会更多用于不同类型的宏任务和微任务的队列。这使得事件循环能够根据任务类型进行优先处理。例如，优先考虑对性能敏感的任务，如用户输入。另一方面，由于在市面上的浏览器和JavaScript执行环境多如牛毛，所以如果发现所有任务都在一个队列的事件循环，也不要过分惊讶。\n事件循环基于两个基本原则：\n\n一次处理一个任务\n一个任务开始后直到运行完成，不会被其他任务中断\n\n注意处理宏任务和微任务队列之间的区别：单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理。\n每当执行一个任务时，事件循环总是首先检查微任务队列，目的是在处理其他任务之前把所有的微任务执行完毕。\n在两个宏任务之间，可以重新渲染页面（主线程和第一个按钮单击任务之间），而在微任务执行之前不允许重新渲染页面\n事件处理器的优点之一是，我们可以创建任意数量的事件处理器，并且事件处理器之间是完全独立的。\n","plink":"https://yanoo1497.github.io/post/js/"},{"title":"JS 原型链速记总结","date":"2020-02-16T07:32:22.000Z","updated":"2021-06-12T10:38:29.429Z","content":"\n主要是为了方便自己遗忘时的一份简洁的速记列表，截取自文章：帮你彻底搞懂JS中的prototype、proto与constructor（图解）\n\n代码示例辅助讲解\n12function Foo() &#123;...&#125;;let f1 = new Foo();\n\n记录图：\n图解关键记忆点：\n\n__proto__ 和 constructor 属性是对象所独有的；\n  __proto__属性都是由一个对象指向它的原型对象(父对象)，通过 __proto__ 属性来连接对象直到 null 的一条链即为我们所谓的原型链。\n  constructor 是由对象指向它的构造函数，每个对象都有构造函数（本身拥有或继承而来。Function 这个对象比较特殊，它的构造函数就是它自己（因为 Function 可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由 Function 构造函数得来，所以 constructor 属性的终点就是 Function 这个函数。\n\nprototype 属性是函数所独有的，它是从一个函数指向它的的原型对象。因为 JS 内函数也是对象，因而函数也具有对象的一切属性。上面的例子中 f1.__proto__ === Foo.prototype。\n  对于 prototype 的作用：包含可以由特定类型的所有实例共享的属性和方法，任何函数在创建的时候，都会默认同时创建该函数的prototype对象。\n\n\n","plink":"https://yanoo1497.github.io/post/prototype/"},{"title":"利用 prototype 重写 console 实现前端错误统计捕获","date":"2020-02-16T06:32:22.000Z","updated":"2021-06-12T10:38:29.428Z","content":"背景由于业务上的需求，需要对已经写好的旧项目进行 log、warn、error、debug 等的数据进行统计，但是又不希望改动影响到旧代码。\n思路主要是利用 js 的原型链，新写一个 console 继承自原始 console 然后对需要统计的方法那边进行重写捕获对应数据。\n具体代码实现1234567891011121314151617181920212223242526272829303132333435363738import &#123; appendFileSync &#125; from 'fs';import &#123; outputFileSync &#125; from 'fs-extra';import &#123; join &#125; from 'path';/** * 自定义的一个新 console 类型，用于收集日志 */export class NewConsole &#123;    // --------------------- 重写 console 相关方法 -------------------------    public log(...args: any[]) &#123;        rawConsole.log(...args);        // ... 统计处理    &#125;    public error(...args: any[]) &#123;        rawConsole.error(...args);        // ... 统计处理    &#125;    public warn(...args: any[]) &#123;        rawConsole.warn(...args);        // ... 统计处理    &#125;    public debug(...args: any[]) &#123;        rawConsole.debug(...args);        // ... 统计处理    &#125;&#125;export const rawConsole = console;export const newConsole = new NewConsole();// @ts-ignore 手动继承 consolenewConsole.__proto__.__proto__ = rawConsole;// @ts-ignore 将处理过的继承自 console 的新对象赋给 windowswindow.console = newConsole;\n\n手动继承其实不是最好的方式，但是因为这个 console 的实现想要用正规的继承方式会比较麻烦困难以内采用了这种方式。\n","plink":"https://yanoo1497.github.io/post/console/"},{"title":"你可能不知道的 vscode 使用技巧","date":"2020-02-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.383Z","content":"关于快捷键部分\nCtrl + G（跳转对应行）：打开后再输入数字可以快速跳转到当前打开文件的对应行号（该快捷键等于 Ctrl + P 后输入 : 的效果。）\nCtrl + O（跳转符号）： 打开后输入函数名等可以快速定位到对应函数位置（该快捷键等于 Ctrl + P 后输入 @ 的效果。）\n按下 “Cmd + Option + 左 / 右方向键”（Windows 上是 Ctrl + Pagedown/Pageup）在编辑器 Tab 之间进行跳转。\nCtrl + J:可以快速的显示隐藏底部的工具栏\nCtrl + : 创建出不同的编辑器窗口（并排显示）\n“Ctrl + -” （Windows 上是 Alt + Left）跳转回上一次光标所在的位置\n“Ctrl + Shift + -” （Windows 上是 Alt + Right）则可以跳到下一次光标所在的位置\n\n配合鼠标操作的部分\n在光标位置，按下 Ctrl 使用鼠标中键来拖出一个框，在这个框中的代码都会背选中，并且每一行都有一个独立的光标；\n双击鼠标左键选中单词；三击鼠标左键选中当前行；四击选中整个文档（= Ctrl + A);\n\n其他命令通过运行 “切换禅模式”(Toggle Zen Mode)，就可以把侧边栏、面板等全部隐藏。进入禅模式后，只需按下 Escape 键，即可退出禅模式。\n可以通过 debug.toolBarLocation 设置，调整工具栏的位置，比如说 debug.toolBarLocation: docked 就可以将工具栏固定到调试窗口中了。\n","plink":"https://yanoo1497.github.io/post/你可能不知道的vscode使用技巧/"},{"title":"算法系列 —— 二分查找","date":"2020-02-12T14:12:52.000Z","updated":"2021-06-12T10:38:29.427Z","content":"适合二分查找的数据类型：\nSorted （有序的，单调递增或者递减）\nBounded （存在上下界）\nAccessible by index （能够直接跳过索引访问，例如数组，而链表的数据结构就不适合二分法）\n\n时间复杂度： log(n)\n代码实现\n12345678910111213141516171819202122232425/** * @param &#123;number&#125; target * @param &#123;number[]&#125; arr sorted array * @returns &#123;number&#125; index of target in arr or -1 */function binarySearch(target, arr) &#123;    let left = 0;    let right = arr.length - 1;    let mid;    do &#123;            mid = Math.floor((left + right) / 2); // 注意要取整            // 优化版写法            // mid = Math.floor(left + (right - left) / 2); 可避免数值过大时的越界溢出            console.log(left, right, mid, arr[mid]);            if (arr[mid] === target) &#123;                return mid;            &#125; else if (arr[mid] &lt; target) &#123;                left = mid + 1;            &#125; else if (arr[mid] &gt; target) &#123;                right = mid - 1;            &#125;    &#125; while(left &lt;= right)    return -1;&#125;\n\n例题leecode 69 实现一个求平方根的函数解题思路：\n\n二分法代码实现\n12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 二分法 * @param &#123;number&#125; x  * @param &#123;number&#125; precision 精确度,小数点位数 （0-20） * @returns &#123;number&#125; */function sqrtBinary(x, precision) &#123;    if (x &lt; 0) &#123;        // 负数没有平方根        // console.error('...')        return x;    &#125;    // 简单特殊值直接返回    if (x === 0 || x === 1) &#123;        return x;    &#125;    // // 对传入的小数点位数做处理    // if (precision &lt; 0) &#123;    //     precision = 0;    // &#125; else if (precision &gt; 20) &#123;    //     precision = 20;    // &#125; else &#123;    //     precision = Math.floor(precision);    // &#125;    // 实际精确值    const preci = Math.pow(10, -precision);    let l = 0;    let r = x;    let res;    while (r - l &gt;= preci) &#123;        let m = l + (r - l) / 2;        // 注意使用 m 与 x / m 做比较而不是 m * m 可以避免越界        res = m;        if (Math.abs(m - x / m) &lt;= preci) &#123;            break;        &#125; else if ((m - x / m) &gt; preci) &#123;            r = m;        &#125; else if ((m - x / m) &lt; - preci) &#123;            l = m;        &#125;    &#125;    return Number(res.toFixed(precision));&#125;\n\n牛顿迭代法（计算机内部常用，主要是利用 y = x平方 的公式，不断循环找到对逼近的点\n\n\n1234567891011121314/** * 牛顿迭代法，需要先自行推导公式 * @param &#123;*&#125; x  * @param &#123;*&#125; precision  */function sqrt(x, precision) &#123;    const preci = Math.pow(10, -precision);    let res = x;    let temp = 0;    while ( res * res - x &gt; preci &amp;&amp; temp &lt; 1000) &#123;        res = (res + x / res) / 2;    &#125;    return Number(res.toFixed(precision));&#125;\n\n","plink":"https://yanoo1497.github.io/post/binary-search/"},{"title":"几种字符串匹配算法","date":"2020-02-07T06:32:22.000Z","updated":"2021-06-12T10:38:29.425Z","content":"通常在使用 JS 时，匹配字符串都可以通过现有接口比如是 indexOf() 来直接使用，但是了解一下底层的实现原理还是很有必要的，这篇文章介绍了常见的几种字符串匹配算法，主要是涉及主串 A 中匹配子串 B 的不同解法思路。\nBF(Brute Force) 算法\n介绍：在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的，匹配方式就是逐一比对过去，在每一个起始位置逐一比对下去。\n\n优点：简单，不易出错，符合 KISS 原则\n\n缺点：暴力解法，最坏情况下的时间复杂度为 O(n*m)\n\n应用场景：在字符串比较短时，不失为一个不错的选择\n\n\nRK(Rabin-Karp) 算法\n介绍：其实就是 BF 算法的升级版，BF 方法的基础上，改进了判断是否匹配的算法。在 BF 算法中，匹配方式是采用逐一字符串匹配的方式，如果使用模式串的哈希值来比对判断就会大大提高匹配的速度。在哈希算法合理的情况下（暂不考虑哈希冲突），此算法的复杂度就是 O(n)。\n  所以此方法的优化点主要在于哈希算法的设计上，具体就需要看根据具体需要匹配的字符串的规律了。例如如果是纯字母的话，可以转 26 进制、取字符相加的值等。当然，如果遇到哈希冲突时一样需要退化使用最原始的逐字符比对的方式。\n\n优点：理解简单，容易维护\n\n缺点：依赖于哈希算法的设计，如果设计不好冲突多或者计算复杂的话反而会提高复杂度。\n\n\nBM(Boyer-Moore) 算法\n介绍：BM算法的核心思想是通过将模式串沿着主串大踏步的向后滑动，从而大大减少比较次数，降低时间复杂度。而算法的关键在于如何兼顾步子迈得足够大与无遗漏，同时要尽量提高执行效率。这就需要模式串在向后滑动时，遵守坏字符规则与好后缀规则，同时采用一些技巧。  具体细节理解可以参考\n优点：有实验表明它的性能是著名的 KMP 算法的 3 到 4 倍。\n缺点：不是太好理解，代码变复杂，不利于维护\n\nKPM 算法\n介绍：时间复杂度是 O(n+m),…待更新\n\n参考文章：\n\n漫画：什么是字符串匹配算法？（通俗易懂）\n\n","plink":"https://yanoo1497.github.io/post/string/"},{"title":"2020 春节周记","date":"2020-02-07T06:32:22.000Z","updated":"2021-06-12T10:38:30.364Z","content":"一些好的文章\n对不起，学会这些计算机基础知识后我飘了 主要是关于计算机基础知识的内容，内容有点干，长文。\n\n关于括号匹配的一道算法题文章中记录了面试过程中面试官由浅入深的询问，以及同类算法的不同解答方式，警示我们在遇到简单问题时应该要多去思考是否还有更优的解法，不管是在时间复杂度还是空间复杂度上都要去做思考。\n\n一口（很长的）气了解 babel 一则关于 babel 基础知识的普及文章。\n\n一个合格(优秀)的前端都应该阅读这些文章 前端资料汇总，这个可以当做长期任务，阅读后汇总到自己的笔记内，目前看来里面的内容虽然很多但是有些文章并不属于我看过的同类型话题里我觉得写得最好的。\n\n箭头函数的使用注意事项 主要是要注意：this 指向、arguments 参数、constructor、不可以使用yield命令\n\n\n其他散文章的收获\n网页内字体通常最好使用偶数，chrome 桌面端最小字体只允许 12 px,需要显示更小字体需要使用图片或者添加新的 css 样式配置。参考了 谈谈网页中使用奇数字体和偶数字体\n\n","plink":"https://yanoo1497.github.io/post/weekly/"},{"title":"js性能优化注意事项","date":"2019-10-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.372Z","content":"原生js部分参考文章\n\njs性能优化的小知识\njavascript性能优化技巧\nJavaScript性能优化之小知识总结\n\nDOM编程建议将对象进行缓存处理，特别是DOM访问是比较消耗资源的使用DocumentFragment优化多次append一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。\n12345678910111213for (var i = 0; i &lt; 1000; i++) &#123;      var el = document.createElement('p');      el.innerHTML = i;      document.body.appendChild(el);    &#125;    //可以替换为：    var frag = document.createDocumentFragment();    for (var i = 0; i &lt; 1000; i++) &#123;      var el = document.createElement('p');      el.innerHTML = i;      frag.appendChild(el);    &#125;    document.body.appendChild(frag);\n\n使用一次innerHTML赋值代替构建dom元素对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。\n12345678910111213var frag = document.createDocumentFragment();for (var i = 0; i &lt; 1000; i++) &#123;  var el = document.createElement('p');  el.innerHTML = i;  frag.appendChild(el);&#125;document.body.appendChild(frag);//可以替换为：var html = [];for (var i = 0; i &lt; 1000; i++) &#123;  html.push('&lt;p&gt;' + i + '&lt;/p&gt;');&#125;document.body.innerHTML = html.join('');\n\n通过模板元素clone，替代createElement很多人喜欢在JavaScript中使用document.write来给页面生成内容。事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。通常我们可能会使用字符串直接写HTML来创建节点，其实这样做，1无法保证代码的有效性2字符串操作效率低，所以应该是用document.createElement()方法，而如果文档中存在现成的样板节点，应该是用cloneNode()方法，因为使用createElement()方法之后，你需要设置多次元素的属性，使用cloneNode()则可以减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点\n12345678910111213141516var frag = document.createDocumentFragment();    for (var i = 0; i &lt; 1000; i++) &#123;      var el = document.createElement('p');      el.innerHTML = i;      frag.appendChild(el);    &#125;    document.body.appendChild(frag);    //替换为：    var frag = document.createDocumentFragment();    var pEl = document.getElementsByTagName('p')[0];    for (var i = 0; i &lt; 1000; i++) &#123;      var el = pEl.cloneNode(false);      el.innerHTML = i;      frag.appendChild(el);    &#125;    document.body.appendChild(frag);\n\n使用firstChild和nextSibling代替childNodes遍历dom元素12345678910var nodes = element.childNodes;    for (var i = 0, l = nodes.length; i &lt; l; i++) &#123;      var node = nodes[i];      //……    &#125;    //可以替换为：    var node = element.firstChild;    while (node) &#123;      //……      node = node.nextSibling;\n\n删除DOM节点删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点使用事件代理任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了dom对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听重复使用的调用结果，事先保存到局部变量\n1234567//避免多次取值的调用开销 var h1 = element1.clientHeight + num1; var h2 = element1.clientHeight + num2; //可以替换为： var eleHeight = element1.clientHeight; var h1 = eleHeight + num1; var h2 = eleHeight + num2;\n\n注意NodeList\n最小化访问NodeList的次数可以极大的改进脚本的性能\n123var images = document.getElementsByTagName('img');for (var i = 0, len = images.length; i &lt; len; i++) &#123;&#125;\n\n编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问进行了对getElementsByTagName()的调用获取了元素的childNodes属性获取了元素的attributes属性访问了特殊的集合，如document.forms、document.images等等要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度\n算法和流程控制建议不要在函数内进行过深的嵌套判断尽量不要用for-in 循环去访问数组，建议用 for 循环进行循环优化循环可以使用下面几种方式来优化循环\n倒序循环大多数循环使用一个从0开始、增加到某个特定值的迭代器，在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效参考文章：javascript for循环从入门到偏门(效率优化+奇特用法)把减法操作放到控制条件中，例如：i–，这样只是比较“它是true吗？”速度更快。\n1234var i = arr.length; for(;i&gt;0;i--)&#123;     //alert(i); &#125;\n\n简化终止条件由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，也就是说避免属性查找或者其它的操作，最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象的遍历时，提前将length保存到局部变量中，避免在循环的每一步重复取值。\n123456789var list = document.getElementsByTagName('p');  for (var i = 0; i &lt; list.length; i++) &#123;    //……  &#125;  //替换为：  var list = document.getElementsByTagName('p');  for (var i = 0, l = list.length; i &lt; l; i++) &#123;    //……  &#125;\n\n简化循环体循环体是执行最多的，所以要确保其被最大限度的优化\n使用后测试循环在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。\n1234567891011var arr = [1, 2, 3, 4, 5, 6, 7];var sum = 0;for (var i = 0, l = arr.length; i &lt; l; i++) &#123;  sum += arr[i];&#125;//可以考虑替换为：var arr = [1, 2, 3, 4, 5, 6, 7];var sum = 0, l = arr.length;while (l--) &#123;  sum += arr[l];&#125;\n\n最常用的for循环和while循环都是前测试循环，而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。\n展开循环当循环次数是确定的，消除循环并使用多次函数调用往往会更快。\n避免双重解释如果要提高代码性能，尽可能避免出现需要按照JavaScript解释的字符串，也就是\n####### 尽量少使用eval函数使用eval相当于在运行时再次调用解释引擎对内容进行运行，需要消耗大量时间，而且使用Eval带来的安全性问题也是不容忽视的。不要使用Function构造器不要给setTimeout或者setInterval传递字符串参数\n12345678var num = 0;    setTimeout('num++', 10);    //可以替换为：    var num = 0;    function addNum() &#123;      num++;    &#125;    setTimeout(addNum, 10);\n\n缩短否定检测\n12345678910111213if (oTest != '#ff0000') &#123;  //do something&#125;if (oTest != null) &#123;  //do something&#125;if (oTest != false) &#123;  //do something&#125;//虽然这些都正确，但用逻辑非操作符来操作也有同样的效果：if (!oTest) &#123;  //do something&#125;\n\n条件分支将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数在同一条件子的多（&gt;2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。使用三目运算符替代条件分支\n1234567if (a &gt; b) &#123;      num = a;    &#125; else &#123;      num = b;    &#125;    //可以替换为：    num = a &gt; b ? a : b;\n\n数据存取使用直接量123456789101112var aTest = new Array(); //替换为    var aTest = [];    var aTest = new Object; //替换为    var aTest = &#123;&#125;;    var reg = new RegExp(); //替换为    var reg = /../;    //如果要创建具有一些特性的一般对象，也可以使用字面量，如下：    var oFruit = new O;    oFruit.color = \"red\";    oFruit.name = \"apple\";    //前面的代码可用对象字面量来改写成这样：    var oFruit = &#123; color: \"red\", name: \"apple\" &#125;;\n\n字符串连接如果要连接多个字符串，应该少使用+=，如s+=a;s+=b;s+=c;应该写成s+=a + b + c；而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来\n12345var buf = [];for(vari = 0; i &lt; 100; i++) &#123;    buf.push(i.toString());&#125;var all = buf.join(\"\");\n\n避免with语句和函数类似 ，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的代码要慢，在能不使用with语句的时候尽量不要使用with语句。\n12345678with(a.b.c.d) &#123;    property1 = 1;    property2 = 2;&#125;//可以替换为：var obj = a.b.c.d;obj.property1 = 1;obj.property2 = 2;\n\n数字转换成字符串一般最好用”” +1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：\n1(“” +) &gt; String() &gt; .toString() &gt; newString()\n\n浮点数转换成整型很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()\n各种类型转换1234567var myVar = \"3.14159\",    str = \"\" + myVar, // to string     i_int = ~ ~myVar, // to integer     f_float = 1 * myVar, // to float     b_bool = !!myVar, /* to boolean - any string with length                 and any number except 0 are true */    array = [myVar]; // to array\n\n如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高\n多个类型声明在JavaScript中所有变量都可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。\n使用常量重复值:任何在多处用到的值都应该抽取为一个常量用户界面字符串:任何用于显示给用户的字符串，都应该抽取出来以方便国际化URLs:在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL任意可能会更改的值:每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。避免与null进行比较由于JavaScript是弱类型的，所以它不会做任何的自动类型检查，所以如果看到与null进行比较的代码，尝试使用以下技术替换如果值应为一个引用类型，使用instanceof操作符检查其构造函数如果值应为一个基本类型，作用typeof检查其类型如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上\n避免全局量全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//糟糕的全局变量和全局函数var current = null;function init()&#123;//...&#125;function change() &#123;  //...&#125;function verify() &#123;  //...&#125;//解决办法有很多，Christian Heilmann建议的方法是：//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。(function()&#123;var current = null;function init() &#123;  //...&#125;function change() &#123;  //...&#125;function verify() &#123;  //...&#125;&#125;)();//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据myNameSpace = function() &#123;  var current = null;  function init() &#123;    //...  &#125;  function change() &#123;    //...  &#125;  function verify() &#123;    //...  &#125;//所有需要在命名空间外调用的函数和属性都要写在return里面  return &#123;    init: init,    //甚至你可以为函数和属性命名一个别名    set: change  &#125;;&#125;;```js##### 避免全局查找将全局变量存储到局部变量中：因为全局变量总是存在于执行环境作用域链的最末端，所以，访问全局变量是最慢的，访问局部变量是最快的。尤其是对于未优化过的JavaScript引擎。```jsfunction search() &#123;//当我要使用当前页面地址和主机域名    alert(window.location.href + window.location.host);&#125;//最好的方式是如下这样 先用一个简单变量保存起来function search() &#123;    var location = window.location;    alert(location.href + location.host);&#125;\n\n尊重对象的所有权因为JavaScript可以在任何时候修改任意对象，这样就可以以不可预计的方式覆写默认的行为，所以如果你不负责维护某个对象，它的对象或者它的方法，那么你就不要对它进行修改，具体一点就是说：不要为实例或原型添加属性不要为实例或者原型添加方法不要重定义已经存在的方法不要重复定义其它团队成员已经实现的方法，永远不要修改不是由你所有的对象，你可以通过以下方式为对象创建新的功能:创建包含所需功能的新对象，并用它与相关对象进行交互创建自定义类型，继承需要进行修改的类型，然后可以为自定义类型添加额外功能\n定时器如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器\n123456789101112131415var timeoutTimes = 0;functiontimeout() &#123;timeoutTimes++;if(timeoutTimes &lt; 10) &#123;    setTimeout(timeout, 10);&#125;&#125;timeout();//可以替换为：var intervalTimes = 0functioninterval() &#123;    intervalTimes++;if(intervalTimes &gt;= 10)&#123;    clearInterval(interv);&#125;&#125;var interv = setInterval(interval, 10);\n\n插入迭代器如var name=values[i]; i++;前面两条语句可以写成var name=values[i++]\n循环引用如果循环引用中包含DOM对象或者ActiveX对象，那么就会发生内存泄露。内存泄露的后果是在浏览器关闭前，即使是刷新页面，这部分内存不会被浏览器释放。\n简单的循环引用123456var el = document.getElementById('MyElement');var func = function () &#123;  //…&#125;el.func = func;func.element = el;\n\n但是通常不会出现这种情况。通常循环引用发生在为dom元素添加闭包作为expendo的时候。\n1234567function init() &#123;  var el = document.getElementById('MyElement');  el.onclick = function () &#123;    //……  &#125;&#125;init();\n\ninit在执行的时候，当前上下文我们叫做context。这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。\n下面2种方法可以解决循环引用1)  置空dom对象12345678910111213141516function init() &#123;      var el = document.getElementById('MyElement');      el.onclick = function () &#123;        //……      &#125;    &#125;    init();    //可以替换为：    function init() &#123;      var el = document.getElementById('MyElement');      el.onclick = function () &#123;        //……      &#125;      el = null;    &#125;    init();\n\n将el置空，context中不包含对dom对象的引用，从而打断循环应用。如果我们需要将dom对象返回，可以用如下方法：\n123456789101112131415161718192021function init() &#123;   var el = document.getElementById('MyElement');   el.onclick = function () &#123;     //……   &#125;   return el; &#125; init(); //可以替换为： function init() &#123;   var el = document.getElementById('MyElement');   el.onclick = function () &#123;     //……   &#125;   try &#123;     return el;   &#125; finally &#123;     el = null;   &#125; &#125; init();\n\n2)  构造新的context12345678910111213141516function init() &#123;    var el = document.getElementById('MyElement');    el.onclick = function () &#123;      //……    &#125;  &#125;  init();  //可以替换为：  function elClickHandler() &#123;    //……  &#125;  function init() &#123;    var el = document.getElementById('MyElement');    el.onclick = elClickHandler;  &#125;  init();\n\n 把function抽到新的context中，这样，function的context就不包含对el的引用，从而打断循环引用。通过javascript创建的dom对象，必须append到页面中IE下，脚本创建的dom对象，如果没有append到页面中，刷新页面，这部分内存是不会回收的！\n123456789function create() &#123;  var gc = document.getElementById('GC');  for (var i = 0; i &lt; 5000; i++) &#123;    var el = document.createElement('div');    el.innerHTML = \"test\";    //下面这句可以注释掉，看看浏览器在任务管理器中，点击按钮然后刷新后的内存变化    gc.appendChild(el);  &#125;&#125;\n\n释放dom元素占用的内存将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。\n释放javascript对象在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。\n\n对象：obj = null\n对象属性：delete obj.myproperty\n数组item：使用数组的splice方法释放数组中不用的item\n\n避免string的隐式装箱对string的方法调用，比如’xxx’.length，浏览器会进行一个隐式的装箱操作，将字符串先转换成一个String对象。推荐对声明有可能使用String实例方法的字符串时，采用如下写法：\n1var myString = new String(‘Hello World');\n\n松散耦合1、解耦HTML/JavaScriptJavaScript和HTML的紧密耦合：直接写在HTML中的JavaScript、使用包含内联代码的HTML和JavaScript的紧密耦合：JavaScript中包含HTML，然后使用innerHTML来插入一段html文本到页面其实应该是保持层次的分离，这样可以很容易的确定错误的来源，所以我们应确保HTML呈现应该尽可能与JavaScript保持分离\n2、解耦CSS/JavaScript显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript\n3、解耦应用程序/事件处理程序将应用逻辑和事件处理程序相分离：一个事件处理程序应该从事件对象中提取，并将这些信息传送给处理应用逻辑的某个方法中。这样做的好处首先可以让你更容易更改触发特定过程的事件，其次可以在不附加事件的情况下测试代码，使其更易创建单元测试\n性能方面的注意事项1、尽量使用原生方法2、switch语句相对if较快通过将case语句按照最可能到最不可能的顺序进行组织\n3、位运算较快当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快\n4、巧用||和&amp;&amp;布尔运算符123456789101112function eventHandler(e) &#123;     if (!e) e = window.event;   &#125;   //可以替换为：   function eventHandler(e) &#123;     e = e || window.event;   &#125;   if (myobj) &#123;     doSomething(myobj);   &#125;   //可以替换为：   myobj &amp;&amp; doSomething(myobj);\n\n避免错误应注意的地方1、每条语句末尾须加分号在if语句中，即使条件表达式只有一条语句也要用{}把它括起来，以免后续如果添加了语句之后造成逻辑错误\n2、使用+号时需谨慎JavaScript 和其他编程语言不同的是，在 JavaScript 中，’+’除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符’++’混淆而引起计算错误\n123456var valueA = 20;var valueB = \"10\";alert(valueA + valueB);   //ouput: 2010 alert(valueA + (+valueB)); //output: 30 alert(valueA + +valueB);  //output:30 alert(valueA ++ valueB);   //Compile error\n\n3、使用return语句需要注意一条有返回值的return语句不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果\n12345678910111213function F1() &#123;     var valueA = 1;     var valueB = 2;     return valueA + valueB;   &#125;   function F2() &#123;     var valueA = 1;     var valueB = 2;     return     valueA + valueB;   &#125;   alert(F1()); //output: 3    alert(F2()); //ouput: undefined\n\n==和===的区别避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换\n12345678910111213141516var valueA = \"1\";    var valueB = 1;    if (valueA == valueB) &#123;      alert(\"Equal\");    &#125;    else &#123;      alert(\"Not equal\");    &#125;    //output: \"Equal\"    if (valueA === valueB) &#123;      alert(\"Equal\");    &#125;    else &#123;      alert(\"Not equal\");    &#125;    //output: \"Not equal\"\n\n不要使用生偏语法不要使用生偏语法，写让人迷惑的代码，虽然计算机能够正确识别并运行，但是晦涩难懂的代码不方便以后维护\n函数返回统一类型虽然JavaScript是弱类型的，对于函数来说，前面返回整数型数据，后面返回布尔值在编译和运行都可以正常通过，但为了规范和以后维护时容易理解，应保证函数应返回统一的数据类型\n总是检查数据类型要检查你的方法输入的所有数据，一方面是为了安全性，另一方面也是为了可用性。用户随时随地都会输入错误的数据。这不是因为他们蠢，而是因为他们很忙，并且思考的方式跟你不同。用typeof方法来检测你的function接受的输入是否合法\n何时用单引号，何时用双引号虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号\n部署用JSLint运行JavaScript验证器来确保没有语法错误或者是代码没有潜在的问部署之前推荐使用压缩工具将JS文件压缩\n文件编码统一用UTF-8JavaScript 程序应该尽量放在 .js 的文件中，需要调用的时候在 HTML 中以标签前。这样会降低因加载 JavaScript 代码而影响页面中其它组件的加载时间。永远不要忽略代码优化工作，重构是一项从项目开始到结束需要持续的工作，只有不断的优化代码才能让代码的执行效率越来越好\n关于JQ部分这部分很多其实和原生js的优化原理是一样的\n1.用数组方式来遍历jQuery 对象集合如果可以使用复杂的选择器直接选中元素，就不要使用循环，去一个个辨认元素。javascript原生循环方法for和while，要比jQuery的.each()方法快，应该优先使用原生方法。\n在性能方面，对于jQuery each方法这种优雅实现是有代价的。有一个办法能够更快地遍历一个jQuery对象。就是通过数组来实现，jQuery对象集合就是一个类数组，具有length和value属性。\n2.选择器优化选择器执行速度：id选择器&gt;class选择器&gt;后代Class选择器&gt;后代选择器&gt;伪类与属性选择器\n3. 理解子元素和父元素的关系当父元素已经生成可以链式操作时，最佳选择是$parent.find(‘.child’)。由于$parent往往在前面的操作已经生成，jQuery会进行缓存，所以进一步加快了执行速度。当父元素未生成，为选择元素添加context选择区域会更快。$(‘.child’, $(‘#parent’))\n\n$parent.find(‘.child’)&gt; $(‘.child’, $parent)&gt;$(‘.child’, $(‘#parent’))&gt;$parent.children(‘.child’)&gt;$(‘#parent &gt; .child’)&gt;$(‘#parent .child’)\n\n(1) $(‘.child’, $parent)这条语句的意思是，给定一个DOM对象，然后从中选择一个子元素。jQuery会自动把这条语句转成$.parent.find(‘child’)，这会导致一定的性能损失。它比最快的形式慢了5%-10%。\n(2) $parent.find(‘.child’)这条是最快的语句。.find()方法会调用浏览器的原生方法（getElementById，getElementByName，getElementByTagName等等），所以速度较快。\n(3) $parent.children(‘.child’)这条语句在jQuery内部，会使用$.sibling()和javascript的nextSibling()方法，一个个遍历节点。它比最快的形式大约慢50%。\n(4) $(‘#parent &gt; .child’)jQuery内部使用Sizzle引擎，处理各种选择器。Sizzle引擎的选择顺序是从右到左，所以这条语句是先选.child，然后再一个个过滤出父元素#parent，这导致它比最快的形式大约慢70%。\n(5) $(‘#parent .child’)这条语句与上一条是同样的情况。但是，上一条只选择直接的子元素，这一条可以于选择多级子元素，所以它的速度更慢，大概比最快的形式慢了77%。\n(6) $(‘.child’, $(‘#parent’))jQuery内部会将这条语句转成$(‘#parent’).find(‘.child’)，比最快的形式慢了23%。\n4.有原生方法可以使用的场合，尽量避免使用jQuerythis.id的速度比$(this).attr(‘id’)快了20多倍；\n5.做好缓存使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。\n6.使用链式写法采用链式写法时，jQuery自动缓存每一步的结果，因此比非链式写法要快。7.事件的委托处理\n8.少改动DOM结构\n改动DOM结构开销很大，因此不要频繁使用.append()、.insertBefore()和.insetAfter()这样的方法。如果要插入多个元素，就先把它们合并，然后再一次性插入。根据测试，合并插入比不合并插入，快了将近10倍。\n如果你要对一个DOM元素进行大量处理，应该先用.detach()方法，把这个元素从DOM中取出来，处理完毕以后，再重新插回文档。根据测试，使用.detach()方法比不使用时，快了60%。\n如果你要在DOM元素上储存数据，不要写成下面这样：\n\n123var elem = $('#elem');elem.data(key,value);\n\n而要写成\n12var elem = $(&apos;#elem&apos;);$.data(elem[0],key,value);\n\n根据测试， 后一种写法要比前一种写法，快了将近10倍。因为elem.data()方法是定义在jQuery函数的prototype对象上面的， 而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用，所以速度快得多。（此处可以参阅下面第10点。）\n\n插入html代码的时候，浏览器原生的innterHTML()方法比jQuery对象的html()更快。\n\n9.选择作用域链最短的方法Javascript的变量采用链式作用域。读取变量的时候，先在当前作用域寻找该变量，如果找不到，就前往上一层的作用域寻找该变量。因而读取局部变量比读取全局变量快得多。\n","plink":"https://yanoo1497.github.io/post/js1/"},{"title":"周记(2019-10-7 —— 2019-10-13)","date":"2019-10-13T08:45:23.000Z","updated":"2021-06-12T10:38:29.415Z","content":"文章阅读推荐\n谈谈算法的学习\n\nChrome Devtools 高级调试指南（新）\n\n\n\n","plink":"https://yanoo1497.github.io/post/weekly/"},{"title":"《小狗钱钱》——博多·舍费尔 书摘","date":"2019-10-07T07:20:41.000Z","updated":"2021-06-12T10:38:29.394Z","content":"小狗钱钱\n◆ 前言\n\n我起初有些担心，人们在读故事时，不是努力去挖掘故事情节之后隐藏的生活原则，而是试图模仿书中主人公获取成功的举动。成功的故事很少有精彩的翻版，但是故事中包含的道理却可以帮助我们在遭遇困境时找到最佳的出路。同样，当我发现读者开始崇拜作者本人，而没有掌握书中叙述的古老真理时，我也有些不安。个人的经历是很难效仿的，但最基本的真理却完全可以复制。\n\n在听或者看一个成功故事的时候要多去研究这些成功背后的规律而不是仅仅只是表面的效仿。\n\n我们常常会过于迅速地得出结论：“这我已经知道了。”似乎认识几个关键词就足够了。这种想法很可能是一个陷阱，因为当我们发现对要学的东西早已熟悉时，可能就不会继续学习下去。因为我们觉得自己已经知道了，所以就对这些信息不再感兴趣。\n\n这个概念在《跃迁》里面也提到过，有很多人并不是没有学习而是“学”的太快太多了，“学习会有瞬间理解的快感，而练习却反复暴露自己的智商。其实后者才是成长之路”。大多数人都在匆匆一瞥之后，并给予自己已经学到了心理暗示从而忽视了后续的实践出真知之理。\n\n“并非困难使我们放弃，而是因为我们放弃，才显得如此困难。”\n\n◆ 第一章 白色的拉布拉多犬\n\n我也不认为钱是人一生中最重要的东西。可是假如我们缺钱的话，钱就会变得格外重要。\n\n和所有的物以稀为贵一样，当一样东西稀缺的时候它就会显得格外重要。类比到其他方面，我们需要格外注意平衡自己生活的各方面，否则我们将会因为某个因素的稀缺而支付超出它市场价格的“代价”。\n◆ 第二章 梦想储蓄罐和梦想相册\n\n如果你只是抱着试试看的心态，那么你只会以失败告终，你会一事无成。‘尝试’纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。\n\n这段话非常印象深刻了，做一件事最开始的想法意志很多时候决定了你会为它付出的努力程度，当一个人相信一件事的时候才会愿意为它付出更多。同样的概念在《拆掉思维里的墙》也提到过——“一旦人们意识到一件事情是可能，那么接下来的事情就只是技术和时间问题了”。所以很多时候，思维方式决定我们能否做成做好一件事。\n\n“学习就是认识新观念和新想法的过程。假如人们始终以同一种思维方式来考虑问题的话，那么始终只会得到同样的结果。因为我对你讲述的许多内容是你以前从未接触过的，所以我建议你，在你还没有做之前，不要轻易下结论。没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。”\n\n\n有一只海鸥曾经对我说过：‘在你展翅飞翔之前，你就必须相信自己能到达目的地。’你必须设想自己已经拥有了这些东西，这样你的一个小愿望才会变成一种强烈的渴望。你想象得越多，你的愿望就越强烈，那么你就会开始寻找机会来实现自己的梦想。吉娅，机会到处都是，但是只有在你寻找它的时候，你才能看见它。只有当你心中有了强烈的渴望，你才会去寻觅机会。而当你想象的时候，强烈的渴望就产生了。”\n\n◆ 第三章 达瑞，一个很会挣钱的男孩\n\n“你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。”\n\n\n关于赚钱的法则：第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。\n\n◆ 第五章 钱钱以前的主人\n\n在遇到困难的时候，仍然要坚持自己的想法。一切正常的时候，每个人都能做到这一点。只有当真正的困难出现时才能见分晓。只有少数人能坚定不移地贯彻自己的计划。那些非常成功的人，甚至有能力在他们最困难的时候作出最杰出的表现。情况顺利的时候，人人都能挣到钱。只有在逆境中，一切才能见分晓。\n\n\n当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。\n\n◆ 第六章 爸爸妈妈犯下的错误\n\n1．毁掉信用卡。2．在许可范围内按最低的分期付款数目标准支付。3．将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。4．消费之前问自己，这真的有必要吗？\n\n◆ 第十一章 爸爸妈妈不明白\n\n“幸运其实只是充分准备加上努力工作的结果。”\n\n◆ 第十三章 巨大的危机\n\n“当你写成功日记的时候，你会对自己，对世界，还有对成功的规律作更深入的思考，会越来越多地了解自己和自己的愿望，这样你才会有能力去理解别人。彻底了解自己和世界上的所有秘密，是我们无法完全实现的一种理想，但我们可以一步一步地慢慢接近这种理想。”\n\n","plink":"https://yanoo1497.github.io/post/19-10-07-money/"},{"title":"周记(2019-9-23 —— 2019-10-07)","date":"2019-09-29T10:20:41.000Z","updated":"2021-06-12T10:38:30.359Z","content":"一些文章学习任务\nif 我是前端团队 Leader，怎么制定前端协作规范?\n\n移动 web 最佳实践\n\nnode 线程池技术让文档编译起飞\n\n\n\n看起来也是类似于 web Worker 的用法，和目前在项目内的用法类似，主要还是让耗时任务异步化\n\n\n《小狗钱钱》一本值得推荐的理财入门书籍，附上 书摘和部分读后感\n\n\n虽然是一本理财入门书籍，但是道理往往是互通的，从作者描述的故事中一样可以获取到人生其他方面的感悟，推荐观看，在书摘内附上了我的部分想法。\n\n\n《细节的力量：51件你必须知道的职场小事》书摘\n\n\n虽然翻开这本书的原因源于自己在工作中因为“粗心大意”而导致工作失误，被人觉得是态度不端正。当时我的第一心理反应是反驳对方的观点，但是仔细想想，是不是我们总是习惯于把我们一些不好的习惯或者工作方式归咎于“粗心大意”这个耳熟能详的惯用词汇上？人们总对粗心的人说要细心，可“细心”一样是一个很笼统的词，我想关键要做的是找到自己在某个步骤之所以会漏掉某个处理的原因所在。是没有认真检查，还是思维局限，技术水平限制又或者是其他十分不好的习惯？而我打开这本书也是想要看看，一些“最佳实践”是怎样的，有哪些可以应用到自己的日常生活中的。与其说是职场的细节不如说是生活中的细节，这些小点其实在做任何事都适用，所以推荐观看，当然知道懂得道理和应用于生活之间隔着千山万水具体还是得看对自己的感触多大行动力多少。\n\n一些简单实践结论\nobject.freeze 和 proxy 都是只能冻结/代理浅拷贝的内容，想要深层次的处理需要自己手动递归处理\n\n关于 node 线程池的共享内存并没有想象中的那样使用方便，一样需要经过转换才能取得那部分数据并且多了一层封装还会使结构变得复杂。\n\n\n","plink":"https://yanoo1497.github.io/post/19-9-23-wenkend/"},{"title":"《细节的力量：51件你必须知道的职场小事》书摘","date":"2019-09-29T01:20:41.000Z","updated":"2021-06-12T10:38:29.393Z","content":"细节的力量：51件你必须知道的职场小事 —— Flanagan裕美子\n◆ 03 失误 不怕麻烦，反复检查\n\n无论被训斥还是被批评，工作是不等人的。这时，我会反复对自己讲以下4点：1．重新调整日程，分配好时间再开始工作。2．制作“清单”，避免失误。3．必须要做到“检查三次”。4．即使失败也不要感到沮丧。\n\n\n在纸上罗列出自己在平时工作中容易出现的失误。利用清单，筛选出自己遗漏的问题或是重复犯的错误，等等。虽然我们想要尽量避免犯错，但很多时候很难做到这一点。这时，我们就要利用清单，消灭错误。\n\n◆ 06 预先准备 通勤时间也是当天工作的准备时间\n\n关于如何利用上下班的通勤时间这件事，做到上班和下班时间做180°相反的事是最为理想的。下班就是放松的时间，放松自己工作中紧绷了一天的神经，做一些自己喜欢的事。但是，上班则是一天工作的开始，是非常重要的准备时间。是否能够充分利用这个时间，会对当天的“工作效率”带来很大影响。\n\n◆ 07 惯性思维 工作状况瞬息万变，要抛掉“思维定势”\n\n无论这个人多厉害，他提供的信息也不一定都是正确的。正因为如此，在任何情况下都要做到“亲自确认信息”，自己对自己负责。亲自确认信息并不是不相信别人、质疑别人。而是心怀感激地接受别人带来的信息，在这个基础上“为了自保，才要自己去确认”。每天都要完成的工作其实并不是完全一成不变的。因此，要把每天的每一项工作当成“新的项目”来对待，无论多麻烦都要自己亲自确认。无论多么有自信也不要“过度自信”，要认真地调查所有相关信息。\n\n◆ 09 保存记录 使用一切手段保留记录，关键时刻可以“保身”\n\n无论任何事情都要做好记录，这样可以减少工作中出现的问题，节约时间。\n\n◆ 10 避免疏忽 再小的工作也要当成重要的事去做\n\n越是工作出色的人，也越是会注意细节。他们总是秉持着“交给自己的工作没有优劣之分”的原则，认真完成每项工作。因为他们知道，没有什么工作是不重要的，低估工作的重要性一定会给自己带来大麻烦。\n\n\n工作上的事不分大小，只有紧急程度的区别，但是所有事都很重要。忘记了这个道理，就有可能吃大亏。为了避免发生不可挽回的错误，请认真对待每一个日常工作。工作有缓急，但没有轻重。\n\n◆ 06 表达 抛掉“对方应该能明白”的“想当然”\n\n最危险的就是想当然地认为“别人都应该知道”。每个人都有各自的思维方式，就像一千个读者的眼中有一千个哈姆雷特。因此，认为别人能读懂自己的心思，就想当然地不去表达和诉说，这种想法是非常危险的。当你感到“每个人都不能理解自己”时，其实是你自己没让大家明白你的想法而已。工作的顺利从良好的沟通开始。从此时此刻开始，无论是大事还是小事，请牢记“不表达，就无法传达”这句话，认真和他人沟通。即使觉得对方已经理解自己的想法，也还是要再次确认。如果有了好的想法，即便可能会被否定，也还是要说出来。即使认为自己可以理解对方的想法，也要再询问并确认对方的看法。刚开始不太顺利也没关系，只要有意识地主动沟通，相信一定会提高自己的沟通能力。\n\n◆ 09 理论武装 用“事实依据”和“理论依据”说服上司\n\n“据说是这样？你调查过没有？有没有数据资料？”从自己身上经手的任何事情，都需要去做一定的引据，因为你经手的事你说的话都是在用你的信用背书。\n\n◆ 06 预防错误 制作待办事项清单，逐个解决\n\n这是因为将需要完成的工作记在笔记上，大脑便可以专注思考其他事情。当脑中闪过好的想法或应做的工作时，就会忽略手边正在做的事情。这是因为当时你的注意力都集中在“一定要牢记这件事”上。将“一定要牢记的事情”记录在纸上或是电脑上，就能够专注于现在正在处理的工作。\n\n◆ 09 积累经验 越是复杂的工作，就越要谨慎\n\n人们通常会下意识地想要逃避麻烦和困难的事。但是一旦完成了这些事，从中获得的经验就会变为自己的财富。如果有机会，一定要勇于挑战这些难题。当你成功后，获得的自信心绝对会给自己的事业和人生带来好的影响。\n\n◆ 4 问题就是机会，迅速解决问题\n\n你只要经历一次挫折，并将其恢复到原本应有的状态，自然就会积累不少经验。因此，我们不要逃避问题，应该尝试解决困难。这种经历绝不是坏事。问题和危机其实是提升他人对你的工作评价和能力评价的机会。\n\n◆ 03 为对方考虑 在解决问题时要照顾“对方的感情”\n\n如果出现失误后的解决步骤1．向对方道歉后，要详细说明准备如何、用多长时间来挽救失误。2．开始采取行动后，依然要用邮件或电话紧密地汇报进度。3．得到最终的结果后，确认对方的态度，并再次道歉。\n\n◆ 05 失败后 分析失败原因，迎接下一次的成功\n\n任何人都会或多或少地犯一些错误。但是对待失败的态度则会影响自己今后的发展。\n\n\n“允许自己继续犯错就是愚蠢，从失败中获得新知识才是明智的做法。”\n\n\n能否将失误转变为“成长的契机”，主要取决于自身如何调整心态。\n\n◆ 06 慌乱 锻炼自己沉着应对突发事件的能力\n\n“意料之外”对于任何立场的人来说都不算是一个好的借口。作为一名职场人士，平时要考虑到种种风险，将“意料之外”归到“预料之中”。但是，万一出现了失误，在因恐慌而造成更多的失误之前，我们要有意识地斩断这种“失误的连锁反应”。\n\n\n“意料之外”对于任何立场的人来说都不算是一个好的借口。作为一名职场人士，平时要考虑到种种风险，将“意料之外”归到“预料之中”。但是，万一出现了失误，在因恐慌而造成更多的失误之前，我们要有意识地斩断这种“失误的连锁反应”。很多时候人们喜欢用这样的心理暗示（意料之外）或者接口来作为自己的免责声明降低自己需要为这次的”考虑不周”所需要承担的责任。但大部分时候的”意料之外”并不是真的完全没有可能想到的，只是你一开始就没有去考虑过这些意外情况，或者觉得为这些可能的意外情况花费太多的时间精力而懒得付出这些精力而导致的。\n\n◆ 5 掌握良好的思维方法，提高自身水平\n\n目光坚定地注视对方时，进一步试探对方，说出自己更高的期待后，很可能会得到意想不到的结果。即便是自己觉得对方不可能答应，也不妨说出来看看。遭到拒绝也没关系，反正自己也已经做好被拒绝的准备，最多说一句“果然如此，但是我也不后悔”。如果对方答应了自己的请求，就自然是再好不过了，“太好了！幸好鼓起勇气说出来了！”不管结果如何，不说出来就无法获得结果，这才是谈判的乐趣。既然要谈判，就不妨愉快地挑战新的高度。\n\n◆ 02 工作姿态 不要否定新想法\n\n以否定新创意来作为安全对策并不难，但这样也无法获得新的发现。\n\n◆ 06 朋友 和“不同”的人在一起反而能拓展思维\n\n你和同部门、从事类似工作的人在一起确实会觉得很稳定、很舒服，但是长此以往，你们的思维方式或方向就会趋于相同。这样就会导致自己无法接触到新的事物和想法，工作氛围也固定了，产生新创意的可能性就会下降。\n\n◆ 08 调动·转岗 逃避工作困难的人会在新岗位上遭遇两倍或三倍的困难\n\n逃跑之前，用尽全力尝试解决问题。这种积极的态度会让你更上一个层次。\n\n","plink":"https://yanoo1497.github.io/post/19-09-29-books/"},{"title":"周记(2019-9-16 —— 2019-9-22)","date":"2019-09-22T10:20:41.000Z","updated":"2021-06-12T10:38:30.363Z","content":"一些不错的文章链接本周末主要还是在研究使用 TypeScript 的新姿势，偶然翻到了一份学习 TypeScript 的资料，顺着那份资源链接去看了英文版的原文，在阅读原文的过程中记录了些许生词与表达句式外加复习了一些关于原型链的知识。具体的阅读收获后续会整合金以往的 TypeScript 学习笔记内，现有的阅读具体链接如下：\n\n《深入学习 TypeScript》\n《TypeScript Deep Dive》\n复习：原生JS实现 new 方法、new 一个对象发生的四部、new 里面常用的优先级\n复习：prototype 原型链相关知识点\n\n一些阅读收获与 tips\n在 switch 里面变量作用域是同一个，可以在 case 里添加 { } 来避免作用域污染\n\n\nhttps://basarat.gitbooks.io/TypeScript/content/docs/let.html\n\n\n关于书写规范空格的说法\n\n\nhttps://github.com/mzlogin/chinese-copywriting-guidelines\n\n\nvue + ts 写法\n （终于能在 vue 组件内愉快的调用 this 了）\n\n\n\nhttps://cn.vuejs.org/v2/guide/TypeScript.html#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\n\n\n关于阅读英文原文的生词句式摘录\n关于《跃迁》读书笔记\n关于数值精度问题可以使用 big.js 或者 math.js 来解决\n\n","plink":"https://yanoo1497.github.io/post/2019-9-22-notes/"},{"title":"关于 typescript 学习手记（三）类型推断","date":"2019-09-22T04:22:54.000Z","updated":"2021-06-12T10:38:30.362Z","content":"基础类型推断在变量声明、函数参数声明时，ts 会根据初始值自动推断出变量或参数的类型如果觉得 ts 的类型断言不符合自己预期，可以手动给类型添加类型断言\n12345678910interface Foo &#123;    bar: number;&#125;let foo = &#123;&#125; as Foo; // 利用手动类型断言来避免 ts 报错，但是不是最佳方案，因为这意味着 bar 属性没有被添加时也不会报错foo.bar = 1;// 推荐写法let foo: Foo = &#123;    bar: 1,&#125;\n\n类型兼容性鸭式辩型，原类型必须具备目标类型的必要属性就可以进行赋值。\n1234567891011121314// 接口兼容性，成员少的会兼容成员多的interface X &#123;    a: any;    b: any;&#125;interface Y &#123;    a: any;    b: any;    c: any;&#125;let x: X = &#123;a: 1, b: 2&#125;let y: Y = &#123;a: 1, b: 2, c: 3&#125;x = y; // 符合 ts 规则// y = x; 不符合\n\n函数兼容性\n123456789101112131415161718type Handler = (a: number, b: number) =&gt; &#123;&#125;function hof(handler: Handler) = &#123;&#125;// 1) 参数个数let handler1 = (a: number) =&gt; &#123;&#125;hof(handler1); // 运行正常let handler2 = (a: number, b: number, c: number) =&gt; &#123;&#125;// hof(handler2) 检查不通过// 2) 参数类型（必须匹配）let handler3 = (a: string) =&gt; &#123;&#125;// hof(handler3) 不通过// 3) 返回值类型// 原返回值必须与目标类型的返回值一致，或者目标类型的返回值需要为原返回值的子类型let f = () =&gt; &#123;&#123;name: 'test'&#125;&#125;let g = () =&gt; &#123;&#123;name: 'test'. location: 'Xiamen'&#125;&#125;f = g;// g = f;\n\n枚举类型兼容性\n12eunm Fruit &#123;Apple, Banana&#125;eunm Color &#123;Red, Yellow&#125;\n\n类兼容性\n1// 类的构造函数与静态成员是不作为比较的，如果类有私有成员那么两个类不兼容\n\n泛型兼容性\n123456789101112131415161718192021222324```## 类型保护机制ts 能够在特定区块内保证变量属于某种确定的类型。可以在此区块内放心的引用此了下的属性，或者调用此类型的方法。```ts强制类型断言let lang = type === Type.String ? new Java() : new Javascript();// instanceif (lang instance Java) &#123;    // 在这个区块内， lan 会被认定为是 java 的实例    lang.helloJava();&#125;// inif ('java' in lang) &#123;    lang.hellowJava();&#125;// typeofif (typeof x === 'string') &#123;&#125;\n\n","plink":"https://yanoo1497.github.io/post/typescript/"},{"title":"《TypeScript Deep Dive》（一）——English Learning Weekly","date":"2019-09-22T04:22:54.000Z","updated":"2021-06-12T10:38:29.417Z","content":"\n《TypeScript Deep Dive》\n\nThis week I read the book named《TypeScript Deep Dive》 in English, I found that there many new words、phrases and perfect sentence for me to learn, so I note it.Maybe I can use some expresstion in my documation some day.Below are those sentences and words:\n\nsemantics: 语意\n\ncognitive: 认知\n\nex: n TypeScript because we really want it to be easy for JavaScript developers with a minimum cognitive overload, types are structural.\n\n\nvalid 有效的\n\nspecimen 标本、示例\n\nBut just as a specimen here is an example of a class:\n\n\nsyntax 句法语法\n\ndiagram 图表\n\ninterpretation 解释\n\nportions 部分\n\nTypeScript will try to protect you from portions of JavaScript that never worked (so you don’t need to remember this stuff)\n\n\nnonsensical 无厘头的\n\nother things that are nonsensical in JavaScript\n\n\nEssentially 实际上\n\npragmatic 务实的\n\nThat said TypeScript is very pragmatic about the fact that you do write JavaScript so there are some things about JavaScript that you still need to know in order to not be caught off-guard. Let’s discuss them next.\n\n\nresilient 弹性的\n\ncoercion 控制\n\nAs JavaScript tries to be resilient against programming errors == tries to do type coercion between two variables e.g. converts a string to a number so that you can compare with a number as shown below:\n\n\nmutations 突变、变化\n\nMutations are across all references\n\n\ndistinct 不同\n\nbaz is a new object distinct from foo\n\n\nunwinds 展开\n\nannotation 注解\n\nvalidity 合法性\n\nmindful 细心的\n\nSo be mindful of your usage of this. If you want to disconnect this in a class from the calling context use an arrow function, more on that later.\n\n\nclosure 关闭(js: 闭包)\n\nYou can see that the inner function has access to a variable (variableInOuterFunction) from the outer scope. The variables in the outer function have been closed by (or bound in) the inner function. Hence the term closure.\n\n\nidiosyncrasies 特质\n\nWhenever you are handling numbers in any programming language you need to be aware of the idiosyncrasies of how the language handles numbers. Here are a few critical pieces of information about numbers in JavaScript that you should be aware of.\n\n\nDecimal 十进制\n\nFor those familiar with doubles / float in other languages, you would know that binary floating point numbers do not map correctly to Decimal numbers.\n\n\narithmetic 算术的、算法的\n\nOf-course, these special infinity values also show up with arithmetic that requires it e.g.\n\n\nmanually 手动地\n\nclamp 逼近、夹紧\n\nFurther intuition: Just like values bigger than Number.MAX_VALUE get clamped to INFINITY, values smaller than Number.MIN_VALUE get clamped to 0.\n\n\ni.e. 即\n\nJavaScript has a concept of truthy i.e. things that evaluate like true would in certain positions (e.g. if conditions and the boolean &amp;&amp; || operators).\n\n\nhandy 方便的\n\nHere’s a handy table for your reference.\n\n\nexplicit 明确的\n\nintent 意图\n\nQuite commonly it helps to be explicit that the intent is to treat the value as a boolean and convert it into a true boolean (one of true|false).\n\n\nimplement 实现实施\n\ndive 潜水 潜入\n\nHere we deep dive into why these features are useful followed by how these features are implemented in TypeScript.\n\n\nslated\n\n\nNote: Not all of these features are slated for immediate addition to JavaScript but provide great utility to your code organization and maintenance.\n\n\nspecified 规定\n\nimplicitly 隐式的\n\nIf an access modifier is not specified it is implicitly public as that matches the convenient nature of JavaScript\n\n\nsignificance 意义\n\nNote that at runtime (in the generated JS) these have no significance but will give you compile time errors if you use them incorrectly.\n\n\ninvoked\n\nfunctionality\n\nHaving an abstract modifier primarily means that such functionality cannot be directly invoked and a child class must provide the functionality.\n\n\nshorthand 速记、缩写\n\nis such a common pattern that TypeScript provides a shorthand where you can prefix the member with an access modifier and it is automatically declared on the class and copied from the constructor. \n\n\nnifty 俏皮的\n\nThis is a nifty feature supported by TypeScript (from ES7 actually).\n\n\nconsistently 始终如一\n\nLovingly called the fat arrow (because -&gt; is a thin arrow and =&gt; is a fat arrow)\n\n\nsyntax 句法\n\ndemonstrate 验证证明\n\nThe same example is demonstrated with let:Since we mentioned it, we’d like to demonstrate that functions create a new variable scope in JavaScript. Consider the following:\n\n\nhence 于是\n\nHere the functions close over (hence called a closure)\n\n\nvast 大\n\nlet is extremely useful to have for the vast majority of code. \n\n\nimmutable 一层不变的\n\nconst is a very welcomed addition offered by ES6 / TypeScript. It allows you to be immutable with variables.\n\n\ncumbersome 笨重、笨拙\n\nWithout the awesome structuring support built into JavaScript, creating new objects on the fly would indeed be very cumbersome. Destructuring brings the same level of convenience to getting data out of a structure.\n\n\n\n","plink":"https://yanoo1497.github.io/post/2019-9-21-word/"},{"title":"《跃迁》—— 古典 书摘","date":"2019-09-22T01:20:41.000Z","updated":"2021-06-12T10:38:29.424Z","content":"这里的书摘是微信读书过程中顺手摘录的一些读书笔记，在这里做一些分享，也给计划看这本书的人一些内容参考。\n◆ 走在时代前面的明白人\n\n知道知识在哪儿，比知道知识是什么更重要\n\n◆ 外包大脑，成为超人\n\n大脑不该用来记忆，而是要用来观察、思考、创造和影响他人。这本书谈到的，就是这些在新时代高手必备的认知、一定要理解的社会规律，以及必须掌握的技能。\n\n◆ 头部效应：站位比努力更重要\n\n一个距离你太远的领域，你根本就看不到真实的信息和对手，听到的全是传说、段子或者别人希望你听到的东西。这些信息只能当故事听，根本没法拿来实际操作，你很难从中收获什么有用的信息。\n\n◆ 功利学习法：学得更好，却学得更少\n\n一张银行卡，你存进去再多，如果不知道提取密码，就没法提现；知识也是一样。知识晶体就是知识的提取密码。大部分人学了很多，却因为不知道这个概念，没法提现，非常可惜。反过来说，有很多人学习上投入不大，只是特别擅长整理和结晶，也就是能从众多散乱的知识里拿出不错的产品。知识晶体是整个学习中最关键的一环。\n\n◆ 联机学习者：成为知识的路由器\n\n过去自己学自己悟，才是真本事。信息爆炸时代，“调用”和“整合”他人的答案，显然更加重要。\n\n\n过去一定要自己完全学通了，大彻大悟了才出来教别人。100分教5分的人，老师站着讲，学生“跪”着听；信息时代，往往是一个15分的人教5分的人，大家商量着来，偶尔学生还能教老师几招。在传授稳定的、系统化的知识层面，前者更优；但是在学习最新的，还未有人整理过的知识方面，后者显然更快。\n\n\n这就是三种学习思路。• 自学：自己找答案；• 联机学习：和同行交流，用答案换答案；• 跨界联机学习：跨行学习交流，用答案换答案。你是哪一种思路？可以看看自己遇到问题时的第一反应：• 遇到问题，苦思：“这可怎么办？”想一晚上不得；• 遇到问题，找书：“哪里有答案？”开始通过网络、书来找资料；• 遇到问题，找人：“谁最有可能知道这个答案？在这之前我要准备些什么？”然后准备沟通，提出高质量的问题。联机社交学习才是最快的学习方式。人类历史上三次最著名的知识大爆炸，都是跨界联机学习的直接成果。\n\n\n如果说生物通过基因进化，那么人类社会则通过文化基因进化。他创造了一个词来对应生物基因（gene），即文化基因（memes，模因）。今天，最新的知识的源头并不在某个教授的脑子里或一本教科书的某一页，它们在大脑和大脑的碰撞中，在问题和知识的交汇之处，在一线高手的实战之中。要和知识源头联机。\n\n\n今天，最新的知识的源头并不在某个教授的脑子里或一本教科书的某一页，它们在大脑和大脑的碰撞中，在问题和知识的交汇之处，在一线高手的实战之中。要和知识源头联机。\n\n◆ 终身提问者：问题比答案更有效\n\n一开始我们靠兴趣，但是兴趣多变；然后我们追新知，发现新知进化得比我们学习的速度还快；之后我们回身去读经典，却发现经典一辈子也读不完；于是我们开始寻求底层逻辑。今天，真正串联一个又一个知识的，不是学科知识，而是场景问题。学海无涯，终身学习者很容易陷入为学习而学习的窘境。你需要一棵“问题树”。和知识树不一样，问题树依托一个真实的、高价值，并有可能被解决的问题来展开。它包括4个方面：\n\n1234• 我们面临什么样的问题？• 我们如何知道自己已经解决了这个问题？• 我们会遇到哪些挑战和障碍？• 我们有什么可能的解决方案？\n\n以上4个问题会出现很多关键词，指向各个领域，每个领域又会产生新的关键词，然后生长成一棵关于这个问题的“问题树”。\n亚里士多德的知识树和“产品设计”、“公司运营”的问题树问题树创造知识体系的过程和网络搜索的方式一模一样。你在谷歌输入一个关键词，几毫秒内，电脑生成了一个页面。请注意，这个页面不是世界上“现存”的，而是为了你输入的这个关键词“生成”的。谷歌为你的提问“生成”了一套知识体系。你提出一个问题，就相当于在你的大脑的空白框里输入了这个关键词，从此，你过去的知识、人际网络、生活经验都和这个关键词连接起来，逐渐长成自己的问题树。人类的天性在认知上是吝啬的，很懒惰，学习和思考是一件非常耗能、反人性的事。所以，如果一个知识不能被用来解决问题，就不值得学习。你需要的，是用来解决问题的知识。你要学什么？答案就在于你要解决什么样的问题。增强学习动力的最好方法是找到你真正感兴趣的问题。关于专注和多元的解释在这里也实现了和谐统一。专注于你的问题，调用多元知识。在目标上专注，在手段上多元。未来没有专业，真正的专业是你“特别擅长解决某类型的问题”，才不会管你调用了哪些学科。\n\n提问的力量\n\n12345678出一道题，考考你的记忆力：有一辆车，车上有8个人；第一站，上来了3个，下去了5个；然后，上来了5个，下去了8个；然后，上来了8个，下去了3个；然后，上来了2个人，没有人下去；然后，上来了4个人，下去了一半的人。现在请问，车走了多少站？\n\n你可能会说我耍流氓，你为什么不早说？这个游戏凸显出我们日常的一个困境——当信息多到你记不住的时候，你就会散焦，丢失真正的答案。唯一的解决方法就是提问。提问比答案更有效果。\n\n爱因斯坦说：“如果我必须用一小时解决一个重要问题，我会花55分钟考虑我是否问对了问题。”\n\n\n提问式学习提问即创造提问会倒逼你更新知识、深入思考\n\n\n基于问题的学习符合复利的两个条件：\n\n为了解决问题，昨天的思考和学到的知识会马上应用到今天的解决方案上去，形成迭代；\n如果一个知识有用，就不会被忘记；如果没用，忘记也不可惜。\n\n\n\n比终身学习者更有效的，是终身提问者。终身提问者的学习目标更清晰，更不会在知识树里迷路，问题就是他的明灯。终身提问者的反馈更及时，问题就是他的试金石，他很清楚地知道哪些知识有用、哪些没用。终身提问者的动力更强，因为他知道一个问题解锁以后，会带来更多、更大、更有趣的问题，但一切都要从解开这个问题开始，他孜孜不倦，又平静从容。终身提问者更有号召力，一个足够好的问题，需要很多领域的人共同解决，那些平时没机会一起交流的人因为问题聚首。你的问题有多多，你的知识就有多多。你的问题有多好，你的专业就有多好。人生就是一个个问题解惑的过程。\n\n\n我对自己的员工有一个“百知谷”要求——一个问题，没看完百度、知乎和谷歌搜索前三页，不要浪费别人的时间去提问。\n\n◆ 知识IPO：把知识变现成价值\n\n正如你不可能走完一座大山的所有角落，聪明的探险者懂得做个标记，下次再来，继续向终点进发。整个过程以解决问题为最高标准，持续问自己：“这个知识对于解决问题有用吗？”“如果有用，是当下就有用吗？”如果暂时没有用，做个记号收藏到你的笔记里，以后再看。一旦你能解决一个问题，就要尝试多解决同类型的问题，逐渐让这个解决方案能够应对不同情境，自我进化。\n\n\n高标准输出倒逼输入（O）大部分人欠缺的，是把解决问题的结果传播出去。一方面，写作能把这些知识形成体系，整理成能出手的“知识晶体”。更重要的是，这个过程能兑换价值，让更多人知道你有解决这类问题的能力。这个动作能帮你找到下一轮更大的问题，以及更大的价值，形成迭代。这个循环能持续放大，带来一轮又一轮的知识跃迁。\n\n\n以前每个班上，都有一位爱抄笔记的小朋友，在考试前几天，他成为人见人爱的大明星。其实，每个社群都需要一个首席知识官。整理知识也是一种知识的重建。如果你并不擅长创作知识，尽心尽力地做好首席知识官也是非常了不起的。你也许需要学习笔记、整理脑图、视觉引导，但是千万要记得让知识成为产品，不要成为自嗨的收藏品。\n\n◆ 系统：新手看树木，高手看森林\n\n 数千亿的资金投入非洲，并没有让非洲脱贫；因为贫困是一种政治和心智问题，援助往往让当地官员更加腐败奢华，钱发不到民众手中；即使少数到了穷人手中，他们也倾向于消费一轮，而不是改变困境；\n\n◆ 回路：设计人生的增长引擎\n\n好的破局者往往知道：当一个体验短期很爽的时候，你往往要警惕：长远的损失是什么？而当这个体验短期痛苦的时候，你也需要自我激励：长远的收益会是什么？\n\n\n作为一名系统思考者，你能养成的最好的第一个思维习惯就是逆时间打断负循环：• 如果忙得没空思考，那么没空思考是否让你更忙呢？• 如果因为穷，所以总希望翻盘，那么总希望翻盘是否让你更穷呢？• 看到人口带来贫困的报道时，你也一定要尝试思考，贫困是否也会带来人口增长呢？一旦发现这些情况是首尾相连的，尽快打断这种恶性的负面循环。你可以通过直接打断、引入更多资源，或者搭建新的回路来实现。第二个思维习惯是顺着时间搭建正循环：• 如果写作能为你带来名声，那么如何用名声帮你更好地创作？• 如果技能精进能让你获得成功，那么如何用成功让你更加精进？• 如果做某件事情能让你有所收益，那么如何让收益带来更多类似的事情？第一个问题的答案就是第三章提到的知识IPO，第二个问题的思考结果是联机学习、“以答案换答案”的方式；第三种情况其实就是投资的本质，用赚来的钱继续投资。一旦有了这个意识，你就开始成为一名系统思考者，你的人生开始搭建各种细小的正循环回路，而那些侵蚀你精力的负循环也会慢慢停止。\n\n◆ 层级：看问题很透彻的技术\n\n第一问（Emotion）：我在什么情绪之中？给自己的情绪打个几分？（找出情绪类别）\n\n\n第二问（Event）：发生了什么？尝试客观不带情绪地描述发生了什么事情。如果发现不能客观，还带有情绪化的语言，请返回第一层，继续处理自己的情绪。（挖掘情绪背后的事实）\n\n\n第三问（Target）：我原本想要什么？情绪一定是对自己的不满意，通过对情绪背后事实的描述，就可以发现产生情绪背后的初心——某种期望或目标未能达到。（找到期望目标差距）\n\n\n第四问（Action）：我如何改进？找到目标差距，就要正视自己，如何改变行动从而达到期望的目标。（行动改变）\n\nETA脱困四句关于“脱困四问”我曾经写过一篇完整的解读文章，还设计了一个打印出来随时可用的模板，在我的公众号“古典古少侠”（ID：gudian515）输入“ETA”就可以找到。\n◆ 看世界：开放而专注\n\n高明与不高明的观点的差距并不在于智商，而是在于眼界。在今天，人与人在知识获得上是公平的，眼界的差距会反馈到心智上。这个决定因素，就是视野开放。\n\n\n“开放而专注”九律\n\n见得人好，经常随喜赞叹。\n找到自己领域的知识源头，并分享。\n不随便崇拜谁。一旦崇拜，以他为顶，你的系统就又封闭了。\n不再认为自己不喜欢、看不懂的东西就是傻的。\n小心那些“一切都能解释得通”的上帝视角感理论。\n对水平没你高的人要宽容，因为你也没有掌握真理。\n留出10%~30%的时间，给自己不懂也不太会接触的领域。\n站在更高角度，发现和专注于自己的独特之处。\n专注于自己的人生大问题。\n\n\n◆ 看自己：迟钝而有趣\n\n“迟钝而有趣”七律\n\n对不重要的事，漠不关心。\n忍住第一反应，等待第二反应。\n不追热点，等要点浮现。\n寻求整体最优解，站在长周期做判断。\n多元，定期做点儿不靠谱、有趣无用的事。\n成功是小概率事件，找到自己的无限游戏。\n放下焦虑，不要放下好奇心。\n\n\n◆ 第四节 ETA——教你如何无压高效地前进！\n\n学习有瞬间理解的快感，而练习却反复暴露自己的智商。其实后者才是成长之路。\n\n\n第一个E让你看到情绪。情绪是一个隐形的能量，当你清晰的描述他，就好像给隐身侠泼上墨水，他瞬间没了力量——当你面对和描述情绪，情绪自己消停了。第二个E让你看到真相。很多时候，情绪撤去，真相就显露出来。第三个T让你回到初心。很多时候我们忙于看事情的细节，忘记为什么出发了。第四个A让你开始行动。聚焦未来，聚焦自己，聚焦能做的事情，才是重点。过去的、别人的、不能做的，统统管不着。\n\n\n贪：个人战略、年度计划，三件事。是帮助你戒贪的。你如果真的认真做过“算计要精”“结果心态”，精细画过年度目标的三环，你就应该知道每年能做好的事情到底有多少。嗔：ETA，许多对于人和事的愤怒，其实都源于你对于自己无能的愤怒。ETA让你看清自己的情绪和初心，然后行动。痴：生命之花谈的是平衡——你以为自己在“职业”方面的障碍，可能出在“家庭”上，可能出在“个人成长”上，当你看到了人生的全局，你不会死磕在一个角落。个人战略中的“核心矛盾\n\n","plink":"https://yanoo1497.github.io/post/2019-9-22-yueqian/"},{"title":"English Learning Skills and How we do","date":"2019-09-07T13:05:35.000Z","updated":"2021-06-12T10:38:29.458Z","content":"\n周五开了个关于英语学习的分享会，以下内容是从别人整理过来的内容做一个简单的补充与拷贝，防止忘记。\n\n推荐的英语网站\nNewser: https://www.newser.com/ （比较简单）\nUSA today: https://www.usatoday.com/\nIGN: https://www.ign.com\nPolygon: https://www.polygon.com/\nEngadget: https://www.engadget.com/\nTech Crunch: https://techcrunch.com/\nVenturebeat: https://venturebeat.com/\nTV Guide: https://www.tvguide.com/\nYoutube\n网易公开课: http://open.163.com/special/opencourse/englishs1.html\nEasy FM: https://easyfmlive.com/\nPodcasts\n\n方法技巧\n找到自己的兴趣点或者是目标：听?说?读?写?\n看电视剧：生活化的，理解一遍（中文字幕）、跟读一遍（英文字幕）、整理单词、不带字幕听并能够复述\nDubbing（配音）： 英语趣配音等等软件\n基础：词汇、语法（时态、语态）\n词汇：要要关注词汇的几个要素 ：音、形、意、用，缺一不可，尤其是应用。想办法给用上自己新学到的单词，可以造句等等。\n听写：只是简单的听一遍是远远不够的\n起床和睡觉前听英文，给大脑足够多的英语浸泡\n\n","plink":"https://yanoo1497.github.io/post/weekly-English-9-7/"},{"title":"关于 typescript 学习手记（二）接口声明","date":"2019-09-07T11:49:19.000Z","updated":"2021-06-12T10:38:29.412Z","content":"函数类型接口1234567891011// 利用实现直接定义了接口function add(x: numver, y: number): number;// 三种不同的函数接口定义方式let add (x: numver, y: number) =&gt; number;interface Add &#123;    (x: number, y: number): number&#125;type Add = (x: numver, y: number) =&gt; number;let add: Add = (a, b) =&gt; a + b;\n\n对象类型接口123456789101112// 混合接口interface Lib &#123;    (): void;    version: string;    doSomething(): void;&#125;// function getLib() &#123; 可以创建多个 lib 实例的方法let lib: Lib = () =&gt; &#123;&#125; as Lib; // 使用类型断言lib.version = '1.0';lib.doSomething = () =&gt; &#123;&#125;;//   return lib;// &#125;\n\n类类型接口接口声明的成员属性和方法，在类的实现中都必须要有。接口只能约束类的公有成员，也不能约束类的构造函数接口可以像类一样继承\n// TODO 这部分类的实现与接口直接的关系自己还有点混乱需要重新整理\n1234567891011121314151617181920212223242526interface Human &#123;    name: strng;    eat(): void;&#125;class Asian implements Human &#123;    constructor(name: string) &#123;        this.name = name;    &#125;    name: string;&#125;interface Man extends Human &#123;    run(): void;&#125;interface Child extends Human &#123;    cry(): void;&#125;// 可以合并两个接口的约束interface Boy extends Man, Child &#123;&#125;;let boy: Boy = &#123;    name: '',    run() &#123;&#125;,    cry() &#123;&#125;,&#125;\n\n// TODO 未待完续\n","plink":"https://yanoo1497.github.io/post/post-1/"},{"title":"关于 typescript 学习手记（一）基本类型","date":"2019-09-07T04:30:14.000Z","updated":"2021-06-12T10:38:29.413Z","content":"\n用 ts 也算有一段时间了，基本类型是经常用了，但是感觉很多高级功能不清不楚的，并没有发挥使用 ts 编写代码的最大优势。看官网的示例，感觉都比较普通没有解答到我心中的疑惑点。特此回过头来重新了解学习，这篇手记是观看极客时间的视频课《typescript 实战教程》时记录的。第一阶段是简单的收获记录，后续会再看其他文章的观点细化更新笔记内容。\n\ntips: 测试 ts 转 js 的情况，可以直接在官网使用 playgroud 来测试编译后的结果，了解编译后的结构对于我们理解使用 ts 的实际运行效果很有帮助。\n基本类型number\\string\\boolean 等简单基础类型略过枚举类型可以将在程序中将来可能改变的变量，或者是程序中常见的判断硬编码改为更易于理解的枚举类型，有利于程序的可读性。\n1234enum test &#123;    success: '成功了'    fail: '失败了'&#125;\n\n常见的赋值方式\n12345678910111213141516171819202122232425262728293031enum Char &#123;    // const 不赋值、赋上枚举值    a,    b: Char.a,    // computed 只有在第一次使用该值后才会被计算    d: Math.random(),    e: '123'.length,&#125;// 常量枚举const enum Month &#123;    Jan,    Feb,    Mar&#125;// 枚举成员的赋值比较约束enum E &#123;a, b&#125;enum F &#123;a = 0, b = 1&#125;enum G &#123;a = 'apple', b = 'banana'&#125;let e: E = 3;let f: F = 3;// 不同类型的枚举变量无法比较let e1: E.a = 3;let e2: E.b = 3;// e1 === e2 这样的判断是不允许let e3: E.a = 1;e1 === e3let g1: G = G.b;let g2: G.a = G.a; // 已经显示指定了 a 就只能赋给 G.a 的值\n\n函数在 ts 中形参和实参必须一一对应，不多不少，同时可选参数必须在必选参数之后。大部分的规则与 es6 类似不过是需要指定参数类型。\n1234567891011121314// 剩余参数function add7(a: number, ...rest:number[]) &#123;    return a + rest.reduce((pre, cur) =&gt; pre + cur);&#125;// 函数重载: 要先以一系列的函数定义声明function add7(...rest: number[]): number;function add7(...rest: string[]): string;function add7(...rest: any[]): any &#123;    const first = rest[0];    if (typeof first === 'string') &#123;        return rest.join('');    &#125; else if (...)    ...&#125;\n\n类继承和成员修饰符类的定义大致与 es 类似，除了需要指定类型外，添加了成员修饰符 private\\public\\protect\\readonly\\static, 具体使用细则可以查看下文代码示例\n1234567891011121314151617181920212223242526272829303132333435class Dog &#123;    constructor(name: string) &#123;        // this.name = name;    &#125;    // 该构建函数既不能被实例化，也不能被继承    private constructor(name: string)    // 该构建函数不能被实例化，只能被继承    protected constructor(name: string)    // 其中 name 形参添加了 public 后会为类自动添加对应的属性    constructor(public name: string)    name: string = 'dog';    // 只能在类内部或者子类内部访问，而不能被实例化后的对象访问    protected name = 'dog';    // 只能在类的内部访问    private name = 'dog';    // 只能通过类名来调用，可以被继承被子类调用，不能通过实例化的对象访问    static constructor(name: string)    static run() &#123;&#125;;    readonly pri: number = 0; // 无法被更改&#125;class Husky extends Dog &#123;    constructor(name: string, public color: string) &#123;        super(name);        // this 要在 super 调用之后访问        this.color = color;    &#125;    // color: string; 构建函数中使用了 public 后不需要再指明成员&#125;\n\n抽象类与继承所谓抽象类，就是只能被继承而不能被实例化的类。所谓多态，在代码上的表现就是不同在子类在继承同一个父类后对同一个方法进行了不同的实现。\n\n抽象类\n\n12345678910111213141516abstract class Animal &#123;    eat() &#123;        console.log('eat');    &#125;&#125;class Dog extends Animal &#123;    constructor(name: string) &#123;        super();        this.name = name;    &#125;    sleep() &#123;        console.log('dog');    &#125;&#125;let dog = new Dog('ccc');dog.eat();\n\n\n多态\n\n123456789class Cat extends Animal &#123;    constructor(name: string) &#123;        super();        this.name = name;    &#125;    sleep() &#123;        console.log('cat');    &#125;&#125;\n\n\n实现方法的链式调用\n\n123456789class WorkFlow &#123;    step1() &#123;        return this;    &#125;    step2() &#123;        return this;    &#125;&#125;new WorkFlow().step1().step2();\n\n泛型\n概念不预先确定的数据类型，具体的类型需要在使用时才能确定\n好处\n\n\n函数和类可以轻松的支持多种类型，增强程序的扩展性\n不必写多条函数重载，冗长的联合类型声明，增强代码可读性\n灵活控制类型之间的约束\n\n\n其他泛型不能用于类的静态成员\n示例\n\n123456789101112131415161718192021222324// 这里的 T 就类似于 any 的作用，但是能保证输入和输出的类型一致function log&lt;T&gt;(value: T): T &#123;    return value;&#125;log&lt;string[]&gt;(['a', 'b'])type Log = &lt;T&gt;(value: T) =&gt; T;interface Log &#123;    &lt;T&gt;(value: T): T&#125;// 约束该类型的所有成员interface Log&lt;T&gt; &#123;    (value: T): T&#125;// 需要指定 number 类型let  myLog: Log&lt;number&gt; = log;// 给类型默认值interface Log&lt;T = string&gt; &#123;    (value: T): T&#125;let  myLog: Log = log;\n\n泛型约束\n12345678910interface Length &#123;    length: number;&#125;function log&lt;T extends Length&gt;(value: T): T &#123;    console.log(value, value.length);    return value;&#125;log([1,3]);log('test');log(&#123;length: 1&#125;);\n\n","plink":"https://yanoo1497.github.io/post/ts/"},{"title":"How I Learn Things Online (Way More Efficiently)——English Learning Weekly","date":"2019-08-31T13:46:15.000Z","updated":"2021-06-12T10:38:30.361Z","content":"\nVideo Link: How I Learn Things Online (Way More Efficiently)\n\nContextStage oneCast a wide net and learn as much as you can about the field that you’re geting into.\nStage twoGo strait to the top.This is a very effective method to distinguishing hight quality from low informations.\nStage threeApply what you are learning.\nVocabulary\ntimestamps: a record in printed or digital form that shows the time at which something happened or was done\nsift : to make a close examination of all the parts of something in order to find something or to separate what is useful from what is no\n\n\nYou have to learn how to sift through the dirt to find the gold.\n\n\nconvince : v. persuade someone or make someone certain\ndiscipline : n. a particular area of study, esp. the ability to control a mental activity. v. to punish someone\n\n\nThe good news is that discipline is like a muscle which means it’s something that you do about it.\n\n\nstrive: to try very hard to do something or to make something happen, especially for a long time or against difficulties\ncrucial : extremely important or necessary\nclueless adj:having no knowledge of something, or of things in general\nincompetence : lack of ability to do something successfully or as it should be done\nunconscious : the part of your mind that contains feelings and thoughts that you do not know about, and that influences the way you behave\nabsorption\ndisciple : a person who believes in the ideas and principles of someone famous and tries to live the way that person does or did子\nevident : easily seen or understood\nbombard : to attack a place with continuous shooting or bombs\nnegotiator : someone who tries to help two groups who disagree to reach an agreement with each other, usually as a job\nlegitimate ：1.reasonable and acceptable 2.allowed by law\nportfolio ： n. a collection of drawings, designs, or other papers that represent a person’s work.\n\n","plink":"https://yanoo1497.github.io/post/weekly/"},{"title":"(How to Think in English to Improve Your English Speaking Skills)——English Learning Weekly","date":"2019-08-18T13:05:35.000Z","updated":"2021-06-12T10:38:29.457Z","content":"\nVideo Link: How to Think in English to Improve Your English Speaking Skills\n\nThis video is about some tips to think in English.Blow are those tips:\n\nTalk to yourself in English.(1) You can do it when you’re brushing your teeth.Just notice anything you like and talk to yourself intentionally in English.(2) You can do it on your way to work.Just talk about what you have to do that day is a good idea.(3) Become a narrator.it means to tell a story about something.(4) To choose a object in your room and spend one full minute describing that object.This will really help you with your fluency,and the next time you see that object,you will automattically begin to think in English,and that’s really important.\n\nDon’t use bilingual dictionary.because when you use a monolingual dictionary,you prevent yourself from translating things word for word.And if you meet some new words,look it up instead in an English-only dirtionary is more helpful.Because you’ll learn so many words as you read the definition and you’ll also learn so many new words that are similar to the one you’re looking for.\n\nTry to describe the word you don’t know\n\nTo keep a diary and to keep a to-do list.It gives us an opportunity to use the new vocabulary and new sentence structure,and it will helps our brain to remenber it.\n\nCreate a mantra in English,it will help you to turn your brain to an English.\n\n\n","plink":"https://yanoo1497.github.io/post/weekly-English-8-18/"},{"title":"(The secrets of learning a new language)——English Learning Weekly","date":"2019-08-11T13:05:35.000Z","updated":"2021-06-12T10:38:29.456Z","content":"\nVideo Link: The secrets of learning a new language\n\n演讲主要阐述了作为热爱学习新语言的作者，在不断的被人询问学语言的奥秘却无法给出一个准确答案后，开始观察和咨询那些精通多国语言的人们如何学习新语言，结果发现每个人似乎都有自己独特的学习一门新语言的习惯和方式，并没有什么通用的方法。但是相同的是，那些对多国语言的学的好的人们大都十分享受语言学习的过程，他们并不将这些语言的学习当做是一门学校的课程，而是一件不介意每天都做的有趣的事。所以不要强求自己去遵循那些学习的教条，如果你暂时没办法找到地道的外国人交流，你完全可以自己模拟这些对话，用新语言来描述你的计划、一天的经过甚至是生活里一些看到的景象用你想要学习的语言描述出来。这些方式，每个人都有条件可以做。在演讲中作者总结了学习一门新语言的关键在于：你要找到这个学习过程的乐趣所在去享受这个学习的过程。当然仅仅只是享受这个乐趣还不够，如果希望能够很流利的运用一门新的语言还需要遵循三条准则：\n\n一个行之有效的方法。短期突击带来的只能是短期记忆，只有长期的重复记忆才能达到最佳效果。可以去利用各种 app 来记忆，如果实在不知道哪些方法是有效的，大可以去那些精通多国语言的人们的博客或者 youtube 频道去看看他们是如何做的，这些都可以激发你灵感。\n要有你自己的学习计划并遵守它，让学习外语融入你的生活成为你的习惯。你可以每天固定时间早起来学习这些内容，在上班路上可以去听一些外语播客的音频，吃饭的时候看 youtube 视频等等，找到你觉得最舒适的方式然后一直坚持下去。\n耐心。学习一门语言不是一朝一夕的事，两个月的学习不能真正掌握一门语言，但是如果你真正享受着完成两个月的学习却有可能带来明显的进步，没有什么比我们取的成就更激励我们了。\n\n","plink":"https://yanoo1497.github.io/post/weekly-English-8-11/"},{"title":"跨浏览器的javascript中鼠标滚轮事件","date":"2019-04-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.373Z","content":"参考：解析javascript中鼠标滚轮事件\nJS滚轮事件(mousewheel/DOMMouseScroll)了解\n1.事件绑定Firefox使用addEventListener添加滚轮事件\n1234/*Firefox注册事件*/if(document.addEventListener)&#123;    document.addEventListener('DOMMouseScroll',scrollFunc,false);&#125;\n\n其中除Firefox外其余均可使用HTML DOM方式添加事件，因此添加事件使用以下方式\n12345/*注册事件*/if(document.addEventListener)&#123;    document.addEventListener('DOMMouseScroll',scrollFunc,false);&#125;//W3Cwindow.onmousewheel=document.onmousewheel=scrollFunc;//IE/Opera/Chrome\n\ndetail与wheelDelta判断滚轮向上或向下的属性值，现在五大浏览器（IE、Opera、Safari、Firefox、Chrome）中Firefox 使用detail，其余四类使用wheelDelta；两者只在取值上不一致，代表含义一致，detail与wheelDelta只各取两个值，detail只取±3，wheelDelta只取±120，其中FireFox浏览器向下滚动是正值，而其他浏览器是负值。\n兼容写法1234567891011121314151617181920212223/** * 简易的判断滚动方向 */var scrollFunc=function(e)&#123;     var direct=0;     e=e || window.event;    var flag;     if(e.wheelDelta)&#123;//IE/Opera/Chrome         if(e.wheelDelta&gt;0)&#123;             flag=\"up\";         &#125;else&#123;              flag=\"down\";         &#125;     &#125;else if(e.detail)&#123;//Firefox        //     &#125; &#125;/*注册事件*/if(document.addEventListener)&#123;    document.addEventListener('DOMMouseScroll',scrollFunc,false);&#125;//W3Cwindow.onmousewheel=document.onmousewheel=scrollFunc;//IE/Opera/Chrome/Safari\n\n","plink":"https://yanoo1497.github.io/post/js2/"},{"title":"无重复字符的最长子串","date":"2019-02-15T06:32:22.000Z","updated":"2021-06-12T10:38:30.368Z","content":"题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1:\n123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n\n示例 2:\n123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n\n示例 3:\n1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。\n\n解答：\n123456789101112131415/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123;    let temp = [];    let result = 0;    for (let i = 0; i &lt; s.length; i ++) &#123;        const index = temp.indexOf(s[i]);        temp.push(s[i]);         index !== -1 &amp;&amp; (temp.splice(0, index + 1));        result = Math.max(result, temp.length)    &#125;    return result;&#125;;\n\n时间复杂度： O(n)\n思路：循环遍历传入的字符串，用一个临时数组存储获取到的子串，用一个变量存储当前不重复子串的最大值。遍历的过程中，如果当前字符与临时数组里没有重复的，就将该字符存入临时数组，同时更新变量取两者的最大值；如果当前字符与临时数组有重复的，记录当前位置，临时数组需要把重复的位置之前的数据都扔掉，继续循环。这样变量里存储的一直是字串的最大值。\n","plink":"https://yanoo1497.github.io/post/Longest-Substring-Without-Repeating-Characters/"},{"title":"node中获取正在运行的全部进程数据","date":"2018-12-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.377Z","content":"问题分析：本质上，这并不是一个关于 node api 的使用。这个问题解决的关键在于，你需要知道使用你当前系统下的命令行工具，需要运行什么命令可以查询系统的全部进程数据，node 只是提供了一个可以运行这样命令的接口罢了。了解了这一点后，问题就很好解决了。\n所以这个问题的第一步是需要知道当前系统该如何查看进程信息，这边系统是 windows ，windows 在命令行中执行 tasklist 可以查看进程信息。\n在知道如何查看后，需要结合 node ，我们需要用 node 中的子进程来执行命令，这边使用 exce详细代码如下：\n123456789const ecxe = require('child_process');exec('tasklist', function(error, stdout, stderr)&#123;    if(error) &#123;        console.error('error: ' + error);        return;    &#125;    console.log('stdout: ' + stdout);    console.log('stderr: ' + typeof stderr);&#125;);\n\n至于其他系统方法类似，只是命令不同罢了。更详细的进程数据分析需要另外再做处理。\n","plink":"https://yanoo1497.github.io/post/node2/"},{"title":"chokidar API","date":"2018-11-12T06:32:22.000Z","updated":"2021-06-12T10:38:30.369Z","content":"github地址：https://github.com/paulmillr/chokidar\nchokidar.watch(paths, [options])**返回一个chokidar构造监听实例\n参数paths一个字符串或者是一个数组，描述监听的文件或者文件夹的路径\n配置对象数据类型常用配置项：\n\npersistent:bollean,与原生fs.watch一样,表示是否保护进程不退出持久监听，默认值为true\nignored:string,所要忽略监听的文件或者文件夹\nignoreInitial:bollean,表示是否忽略对增加文件或者增加文件夹的时候进行发送事件，默认值为false表示add/addDir会触发事件\ncwd:string类型，没有默认值，类似于appBasepath，监听的paths所相对的路径。\nusePolling:bollean，表示是否使用前面提到的fs.watchFile()进行轮询操作，由于轮询会导致cpu飙升，所以此选项通常在需要通过网络监视文件的时候才设置为true即使用fs.watchFile()，默认值为false\ndepth:number类型,没有默认值，如果设定则表示限定了会递归监听多少个子目录。\n\n返回监听实例 FSWatcher APIon(eventName,(path, event) =&gt; {}).add(path / paths)添加文件，目录或glob模式以进行跟踪。支持字符串数组或单独字符串路径\n.on(event, callback)监听支持的事件\n支持的事件名eventName\n\nadd 新增文件时触发\naddDir 新增文件夹的时候触发\nunlink 对应的文件的删除\nunlinkDir 对应的文件夹的删除\nchange 文件内容改变时触发\nall 指代以上所有事件（除了ready, raw, and error之外所有的事件类型）\nready\nraw\nerror 捕获error\n\ncallback (path, event) =&gt; {}path 指代监听到的文件/文件夹路径\n.unwatch(path / paths)停止监听传入文件/文件夹\n.close()从监视文件中移除/关闭所有侦听器\n.getWatched()返回此FSWatcher实例正在监视的文件系统上所有路径的对象，对象的键是所有目录（使用绝对路径，除非使用了cwd选项），并且值是每个目录中包含的项的名称的数组。\n代码示例12345678910const chokidar = require('chokidar')chokidar.watch('testFolder', &#123;  persistent: true,  ignored: /(^|[\\/\\\\])\\../, // 忽略点文件  cwd: '.', // 表示当前目录  depth:0 // 只监听当前目录不包括子目录&#125;).on('all', (event, path) =&gt; &#123;//监听除了ready, raw, and error之外所有的事件类型  console.log(event, path);&#125;);\n\n","plink":"https://yanoo1497.github.io/post/chokidar/"},{"title":"node中对路径分隔符的兼容性处理","date":"2018-10-12T06:32:22.000Z","updated":"2021-06-12T10:38:30.376Z","content":"在编写node程序的时候，经常会遇到的问题是path.resolve或者relative方法返回的结果在linux和windows下不一样。linux返回的路径分隔符是左斜杠（/），而windows返回的路径分隔符是右斜杠（\\）。\n大部分情况下，我们不需要做额外的处理，各自维护自己的路径格式即可，程序本身不需要关心返回的路径格式。但是在调用一些其他模块的时候，可能会遇到这样的问题。分隔符本来也不是什么大问题，但肯定不是简单的字符串替换能解决的。比如，我们需要将windows下拿到的路径转换成linux下的路径。\n1D:\\\\desktop\\\\dev\\\\workspace\\\\k2\\\\seed\\\\seed.js\n\n第一反应是使用replace来解决，但比较推荐的方式是使用path.sep来代替正则的匹配，主要作用是保证代码兼容性的同时也增加代码的可读性，不需要考虑系统版本。\n1&apos;D:\\\\desktop\\\\dev\\\\workspace\\\\k2\\\\seed\\\\seed.js&apos;.split(path.sep).join(&apos;/&apos;);\n\n","plink":"https://yanoo1497.github.io/post/node1/"},{"title":"常用js页面跳转方式","date":"2018-09-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.374Z","content":"工作中会常用到必须用js的页面跳转，刷新，总结了一下常用的js跳转页面的方法和页面刷新及页面自动刷新，js引入js文件的常用技巧，便于查阅。\n1.window.location.href方式\n1window.location.href=\"target.aspx\";\n\n2.window.navigate方式跳转\n1window.navigate(\"target.aspx\");\n\n3.self.location方式实现页面跳转，和下面的top.location有小小区别\n1self.location='target.aspx';\n\n4.top.location\n1top.location='target.aspx';\n\n5.不推荐这种方式跳转\n12alert(&quot;返回&quot;);  window.history.back(-1);\n\n6.小技巧(JS引用JS):\n123if (typeof SWFObject == \"undefined\") &#123;        document.write('&lt;scr' + 'ipt type=\"text/javascript\" src=\"/scripts/swfobject-1.5.js\"&gt;&lt;/scr' + 'ipt&gt;');  &#125;\n\n7.Javascript刷新页面的几种方法：\n12345678history.go(0)  location.reload()  location=location  location.assign(location)  document.execCommand('Refresh')  window.navigate(location)  location.replace(location)  document.URL=location.href\n\n8.自动刷新页面的方法:页面自动刷新：把如下代码加入head区域中,其中20指每隔20秒刷新一次页面.\n1&lt;meta http-equiv=\"refresh\" content=\"20\"&gt;\n\n9.页面自动跳转：把如下代码加入head区域中,其中20指隔20秒后跳转到http://www.qianduandu.com页面\n1&lt;meta http-equiv=\"refresh\" content=\"20;url=http://www.qianduandu.com\"&gt;\n\n10.如果想关闭窗口时刷新或者想开窗时刷新的话，在中调用以下语句即可。\n123&lt;body onload=\"opener.location.reload()\"&gt; 开窗时刷新   &lt;body onUnload=\"opener.location.reload()\"&gt; 关闭时刷新 window.opener.document.location.reload()\n\n","plink":"https://yanoo1497.github.io/post/js3/"},{"title":"sass学习笔记","date":"2018-03-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.379Z","content":"[toc]\n一、入门1.什么是预编译处理器通俗的说，“CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”，例如你可以在 CSS 中使用变量、简单的逻辑程序、函数（如右侧代码编辑器中就使用了变量$color）等等在编程语言中的一些基本特性，可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。\n其它预处理器\nSass（SCSS）\nLESS\nStylus\nTurbine\nSwithch CSS\nCSS Cacheer\nDT CSS\n\n到目前为止，在众多优秀的 CSS 预处理器语言中就属 Sass、LESS 和 Stylus 最优秀，讨论的也多，对比的也多。\n2.什么是 Sass？Sass 是采用 Ruby 语言编写的一款 CSS 预处理语言，它诞生于2007年，是最大的成熟的 CSS 预处理语言。最初它是为了配合 HAML（一种缩进式 HTML 预编译器）而设计的，因此有着和 HTML 一样的缩进式风格。\n3.Sass 和 SCSS 有什么区别？Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点：文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。\n先来看一个示例\nSass 语法123456$font-stack: Helvetica, sans-serif  //定义变量$primary-color: #333 //定义变量body  font: 100% $font-stack  color: $primary-color\n\nScss 语法1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123;  font: 100% $font-stack;  color: $primary-color;&#125;\n\n编译出来的 CSS1234body &#123;  font: 100% Helvetica, sans-serif;  color: #333;&#125;\n\nSass 和 CSS 写法有差别Sass 和 CSS 写法的确存在一定的差异，由于 Sass 是基于 Ruby 写出来，所以其延续了 Ruby 的书写规范。在书写 Sass 时不带有大括号和分号，其主要是依靠严格的缩进方式来控制的。如：\nSass写法123body  color: #fff  background: #f36\n\ncss写法1234body&#123;  color:#fff;  background:#f36;&#125;\n\nSCSS 和 CSS 写法无差别SCSS 和 CSS 写法无差别，这也是 Sass 后来越来越受大众喜欢原因之一。简单点说，把你现有的“.css”文件直接修改成“.scss”即可使用。\n二、SCSS语法格式有不少同学使用 Sass 新的语法规则，而文件扩展名依旧使用的是“.sass”，这也就造成血案了，编译时说编译不出来。在此特别提醒新同学：“.sass”只能使用 Sass 老语法规则（缩进规则），“.scss”使用的是 Sass 的新语法规则，也就是 SCSS 语法规则（类似 CSS 语法格式）。\nSass 编译命令编译命令编译是指使用你电脑中的命令终端，通过输入 Sass 指令来编译 Sass。这种编译方式是最直接也是最简单的一种方式。因为只需要在你的命令终端输入：\n单文件编译1sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css\n\n这是对一个单文件进行编译，如果想对整个项目所有 Sass 文件编译成 CSS 文件，可以这样操作：\n多文件编译1sass sass/:css/\n\n缺点及解决方法在实际编译过程中，你会发现上面的命令，只能一次性编译。每次个性保存“.scss”文件之后，都得重新执行一次这样的命令。如此操作太麻烦，其实还有一种方法，就是在编译Sass 时，开启“watch”功能，这样只要你的代码进行任保修改，都能自动监测到代码的变化，并且给你直接编译出来：\n1sass --watch &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css\n\nGUI工具编译我一直讨厌使用命令来做事情，我喜欢那种能看得到的界面操作。那么你可以考虑使用 GUI 界面工具来对 Sass 进行编译。当然不同的 GUI 工具操作方法略有不同。如果在此也一一对编译的界面工具做详细的介绍。我们可能需要写一本书来介绍这些编译工具的操作了。所以我们这里做一下简单介绍，对于 GUI 界面编译工具，目前较为流行的主要有：\nKoala (http://koala-app.com/)Compass.app（http://compass.kkbox.com/）Scout（http://mhs.github.io/scout-app/）CodeKit（https://incident57.com/codekit/index.html）Prepros（https://prepros.io/）\n相比之下，我比较推荐使用以下两个：\nKoala (http://www.w3cplus.com/preprocessor/sass-gui-tool-koala.html) CodeKit (http://www.w3cplus.com/preprocessor/sass-gui-tool-codekit.html)\n自动化编译1、Gulp 配置 Sass 编译的示例代码1234567891011121314var gulp = require('gulp');var sass = require('gulp-sass');gulp.task('sass', function () &#123;    gulp.src('./scss/*.scss')        .pipe(sass())        .pipe(gulp.dest('./css'));&#125;);gulp.task('watch', function() &#123;    gulp.watch('scss/*.scss', ['sass']);&#125;);gulp.task('default', ['sass','watch']);\n\n设置输出风格\n12345gulp.task('sass', function () &#123; return gulp.src('./sass/**/*.scss')   .pipe(sass(&#123;outputStyle: 'expanded'&#125;).on('error', sass.logError))   .pipe(gulp.dest('./css'));&#125;);\n\n2、Grunt 配置 Sass 编译的示例代码123456789101112131415161718192021module.exports = function(grunt) &#123;    grunt.initConfig(&#123;        pkg: grunt.file.readJSON('package.json'),        sass: &#123;            dist: &#123;                files: &#123;                    'style/style.css' : 'sass/style.scss'                &#125;            &#125;        &#125;,        watch: &#123;            css: &#123;                files: '**/*.scss',                tasks: ['sass']            &#125;        &#125;    &#125;);    grunt.loadNpmTasks('grunt-contrib-sass');    grunt.loadNpmTasks('grunt-contrib-watch');    grunt.registerTask('default',['watch']);&#125;\n\n想了解 Grunt 同学请单击这里学习《Grunt-beginner前端自动化工具》。\n[Sass]常见的编译错误在编译 Sass 代码时常常会碰到一些错误，让编译失败。这样的错误有系统造成的也有人为造成的，但大部分都是人为过失引起编译失败。\n字符编译:而最为常见的一个错误就是字符编译引起的。在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。\n中文字符:另外一个错误就是路径中的中文字符引起的。建议在项目中文件命名或者文件目录命名不要使用中文字符。而至于人为失误造成的编译失败，在编译过程中都会有具体的说明，大家可以根据编译器提供的错误信息进行对应的修改。\n[Sass]不同样式风格的输出方法众所周知，每个人编写的 CSS 样式风格都不一样，有的喜欢将所有样式代码都写在同一行，而有的喜欢将样式分行书写。在 Sass 中编译出来的样式风格也可以按不同的样式风格显示。其主要包括以下几种样式风格：\n\n嵌套输出方式 nested\n展开输出方式 expanded  \n紧凑输出方式 compact\n压缩输出方式 compressed\n\n[Sass]嵌套输出方式 nestedSass 提供了一种嵌套显示 CSS 文件的方式。\n123456789101112131415nav &#123;  ul &#123;    margin: 0;    padding: 0;    list-style: none;  &#125;  li &#123; display: inline-block; &#125;  a &#123;    display: block;    padding: 6px 12px;    text-decoration: none;  &#125;&#125;\n\n在编译的时候带上参数“ –style nested”:\n1sass --watch test.scss:test.css --style nested\n\n编译出来的 CSS 样式风格：\n12345678910nav ul &#123;  margin: 0;  padding: 0;  list-style: none; &#125;nav li &#123;  display: inline-block; &#125;nav a &#123;  display: block;  padding: 6px 12px;  text-decoration: none; &#125;\n\n默认是nested，所以加不加–style nested不影响效果。\n2、嵌套输出方式 expanded这个输出的 CSS 样式风格和 nested 类似，只是大括号在另起一行，同样上面的代码，编译出来：\n12345678910111213nav ul &#123;  margin: 0;  padding: 0;  list-style: none;&#125;nav li &#123;  display: inline-block;&#125;nav a &#123;  display: block;  padding: 6px 12px;  text-decoration: none;&#125;\n\n3、紧凑输出方式 compact该方式适合那些喜欢单行 CSS 样式格式的朋友，编译后的代码如下：\n123nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;\n\n4.压缩输出方式 compressed压缩输出方式会去掉标准的 Sass 和 CSS 注释及空格。也就是压缩好的 CSS 代码样式风格：\n1nav ul&#123;margin:0;padding:0;list-style:none&#125;nav li&#123;display:inline-block&#125;nav a&#123;display:block;padding:6px 12px;text-decoration:none&#125;\n\n编译出来的CSS样式风格的选择完全是个人喜好问题，可以根据自己喜欢的风格选择参数。一段时间之后，你实际上就不再需要写 CSS 代码了，只用写 Sass 代码。在这种情况下，你只需要设定输出格式为压缩格式，知道输出的 CSS 代码可以直接使用即可。\nSass 的调试Sass 调试一直以来都是一件头痛的事情，使用 Sass 的同学都希望能在浏览器中直接调试 Sass 文件，能找到对应的行数。值得庆幸的是，现在实现并不是一件难事，只要你的浏览器支持“sourcemap”功能即可。早一点的版本，需要在编译的时候添加“–sourcemap”  参数：\n1sass --watch --scss --sourcemap style.scss:style.css\n\n在 Sass3.3 版本之上（我测试使用的版本是 3.4.7），不需要添加这个参数也可以：\n1sass --watch style.scss:style.css\n\n在命令终端，你将看到一个信息：\n123&gt;&gt;&gt; Change detected to: style.scss  write style.css  write style.css.map\n\n这时你就可以像展示的 gif 图一样，调试你的 Sass 代码。\nsass的基本特性声明变量在有些编程语言中（如，JavaScript）声明变量都是使用关键词“var”开头，但是在 Sass 不使用这个关键词，而是使用大家都喜欢的美元符号“$”开头。我想用一张图来解释，我一直坚信，一图胜千言万语：上图非常清楚告诉了大家，Sass 的变量包括三个部分：\n\n声明变量的符号“$”\n变量名称\n赋予变量的值\n\n来看一个简单的示例，假设你的按钮颜色可以给其声明几个变量：\n1234$brand-primary : darken(#428bca, 6.5%) !default; // #337ab7$btn-primary-color : #fff !default;$btn-primary-bg : $brand-primary !default;$btn-primary-border : darken($btn-primary-bg, 5%) !default;\n\n如果值后面加上!default则表示默认值。\n注：了解 Bootstrap 的 Sass 版本的同学，就一眼能看出，上面的示例代码是 Bootstrap 定义 primarybutton 的颜色。\n普通变量与默认变量普通变量定义之后可以在全局范围内使用。\n1234$fontSize: 12px;body&#123;    font-size:$fontSize;&#125;\n\n编译后的css代码：\n123body&#123;    font-size:12px;&#125;\n\n默认变量sass 的默认变量仅需要在值后面加上 !default 即可。\n12345678$baseLineHeight:1.5 !default;body&#123;    line-height: $baseLineHeight; &#125;编译后的css代码：body&#123;    line-height:1.5;&#125;\n\nsass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可。\n123456789$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body&#123;    line-height: $baseLineHeight; &#125;编译后的css代码：body&#123;    line-height:2;&#125;\n\n可以看出现在编译后的 line-height 为 2，而不是我们默认的 1.5。默认变量的价值在进行组件化开发的时候会非常有用。\n!default应该是一个默认值，就相当于在一个变量里，先设置一个数值，如果有其他的值则优先替换为实际的，没有其他的则显示这个默认的\n优先级!default &lt; 新属性值 &lt; !important(按css的书写)\nscss中覆盖默认变量的方式：在默认变量之前重新声明\n变量的调用在 Sass 中声明了变量之后，就可以在需要的地方调用变量。调用变量的方法也非常的简单。比如在定义了变量\n1234$brand-primary : darken(#428bca, 6.5%) !default; // #337ab7$btn-primary-color: #fff !default;$btn-primary-bg : $brand-primary !default;$btn-primary-border : darken($btn-primary-bg, 5%) !default;\n\n在按钮 button 中调用，可以按下面的方式调用\n12345.btn-primary &#123;   background-color: $btn-primary-bg;   color: $btn-primary-color;   border: 1px solid $btn-primary-border;&#125;\n\n编译出来的CSS:\n12345.btn-primary &#123;  background-color: #337ab7;  color: #fff;  border: 1px solid #2e6da4;&#125;\n\n全局变量与局部变量Sass 中变量的作用域在过去几年已经发生了一些改变。直到最近，规则集和其他范围内声明变量的作用域才默认为本地。如果已经存在同名的全局变量，从 3.4 版本开始，Sass 已经可以正确处理作用域的概念，并通过创建一个新的局部变量来代替。\n先来看一下代码例子：\n1234567891011121314//SCSS$color: orange !default;//定义全局变量(在选择器、函数、混合宏...的外面定义的变量为全局变量).block &#123;  color: $color;//调用全局变量&#125;em &#123;  $color: red;//定义局部变量  a &#123;    color: $color;//调用局部变量  &#125;&#125;span &#123;  color: $color;//调用全局变量&#125;\n\ncss 的结果：\n12345678910//CSS.block &#123;  color: orange;&#125;em a &#123;  color: red;&#125;span &#123;  color: orange;&#125;\n\n上面的示例演示可以得知，在元素内部定义的变量不会影响其他元素。如此可以简单的理解成，全局变量就是定义在元素外面的变量，如下代码：\n1$color:orange !default;\n\n$color 就是一个全局变量，而定义在元素内部的变量，比如 $color:red; 是一个局部变量。除此之外，Sass 现在还提供一个 !global 参数。!global 和 !default 对于定义变量都是很有帮助的。我们之后将会详细介绍这两个参数的使用以及其功能。\n全局变量的影子当在局部范围（选择器内、函数内、混合宏内…）声明一个已经存在于全局范围内的变量时，局部变量就成为了全局变量的影子。基本上，局部变量只会在局部范围内覆盖全局变量。上面例子中的 em 选择器内的变量 $color 就是一个全局变量的影子。\n1234567891011//SCSS$color: orange !default;//定义全局变量.block &#123;  color: $color;//调用全局变量&#125;em &#123;  $color: red;//定义局部变量（全局变量 $color 的影子）  a &#123;    color: $color;//调用局部变量  &#125;&#125;\n\n什么时候声明变量？我的建议，创建变量只适用于感觉确有必要的情况下。不要为了某些骇客行为而声明新变量，这丝毫没有作用。只有满足所有下述标准时方可创建新变量：\n\n该值至少重复出现了两次；\n该值至少可能会被更新一次；\n该值所有的表现都与变量有关（非巧合）。\n\n基本上，没有理由声明一个永远不需要更新或者只在单一地方使用变量。\n嵌套-选择器嵌套Sass 中还提供了选择器嵌套功能，但这也并不意味着你在 Sass 中的嵌套是无节制的，因为你嵌套的层级越深，编译出来的 CSS 代码的选择器层级将越深，这往往是大家不愿意看到的一点。这个特性现在正被众多开发者滥用。选择器嵌套为样式表的作者提供了一个通过局部选择器相互嵌套实现全局选择的方法，Sass 的嵌套分为三种：\n\n选择器嵌套\n属性嵌套\n伪类嵌套\n\n1、选择器嵌套假设我们有一段这样的结构：\n1234567&lt;header&gt;&lt;nav&gt;    &lt;a href=“##”&gt;Home&lt;/a&gt;    &lt;a href=“##”&gt;About&lt;/a&gt;    &lt;a href=“##”&gt;Blog&lt;/a&gt;&lt;/nav&gt;&lt;header&gt;\n\n想选中 header 中的 a 标签，在写 CSS 会这样写：\n1234567nav a &#123;  color:red;&#125;header nav a &#123;  color:green;&#125;\n\n那么在 Sass 中，就可以使用选择器的嵌套来实现：\n123456789nav &#123;  a &#123;    color: red;    header &amp; &#123;      color:green;    &#125;  &#125;  &#125;\n\n\n&amp;代表&amp;所在的嵌套结构。&amp;理解为父选择器，虽然header是父级，但它写在最里面，&amp;引用父级，即为nav a\n\n嵌套-属性嵌套Sass 中还提供属性嵌套，CSS 有一些属性前缀相同，只是后缀不一样，比如：border-top/border-right，与这个类似的还有 margin、padding、font 等属性。假设你的样式中用到了：\n1234.box &#123;    border-top: 1px solid red;    border-bottom: 1px solid green;&#125;\n\n在 Sass 中我们可以这样写：\n123456.box &#123;  border: &#123;   top: 1px solid red;   bottom: 1px solid green;  &#125;&#125;\n\n嵌套-伪类嵌套其实伪类嵌套和属性嵌套非常类似，只不过他需要借助&amp;符号一起配合使用。我们就拿经典的“clearfix”为例吧：\n1234567891011.clearfix&#123;&amp;:before,&amp;:after &#123;    content:\"\";    display: table;  &#125;&amp;:after &#123;    clear:both;    overflow: hidden;  &#125;&#125;\n\n编译出来的 CSS：\n1234567891011121314151617181920212223242526clearfix:before, .clearfix:after &#123;  content: \"\";  display: table;&#125;.clearfix:after &#123;  clear: both;  overflow: hidden;&#125;```scss#### 避免选择器嵌套：1. 选择器嵌套最大的问题是将使最终的代码难以阅读。开发者需要花费巨大精力计算不同缩进级别下的选择器具体的表现效果。&lt;br&gt;1. 选择器越具体则声明语句越冗长，而且对最近选择器的引用(&amp;)也越频繁。在某些时候，出现混淆选择器路径和探索下一级选择器的错误率很高，这非常不值得。&lt;br&gt;为了防止此类情况，我们应该尽可能避免选择器嵌套。然而，显然只有少数情况适应这一措施。### 混合宏-声明混合宏如果你的整个网站中有几处小样式类似，比如颜色，字体等，在 Sass 可以使用变量来统一处理，那么这种选择还是不错的。但当你的样式变得越来越复杂，需要重复使用大段的样式时，使用变量就无法达到我们目了。这个时候 Sass 中的混合宏就会变得非常有意义。在这一节中，主要向大家介绍 Sass 的混合宏。#### 1、声明混合宏不带参数混合宏：在 Sass 中，使用“@mixin”来声明一个混合宏。如：```scss@mixin border-radius&#123;    -webkit-border-radius: 5px;    border-radius: 5px;&#125;\n\n其中 @mixin 是用来声明混合宏的关键词，有点类似 CSS 中的 @media、@font-face 一样。border-radius 是混合宏的名称。大括号里面是复用的样式代码。带参数混合宏：除了声明一个不带参数的混合宏之外，还可以在定义混合宏时带有参数，如：\n1234@mixin border-radius($radius:5px)&#123;    -webkit-border-radius: $radius;    border-radius: $radius;&#125;\n\n复杂的混合宏上面是一个简单的定义混合宏的方法，当然， Sass 中的混合宏还提供更为复杂的，你可以在大括号里面写上带有逻辑关系，帮助更好的做你想做的事情,如：\n12345678@mixin box-shadow($shadow...) &#123;  @if length($shadow) &gt;= 1 &#123;    @include prefixer(box-shadow, $shadow);  &#125; @else&#123;    $shadow:0 0 4px rgba(0,0,0,.3);    @include prefixer(box-shadow, $shadow);  &#125;&#125;\n\n这个 box-shadow 的混合宏，带有多个参数，这个时候可以使用“ … ”来替代。简单的解释一下，当 $shadow 的参数数量值大于或等于“ 1 ”时，表示有多个阴影值，反之调用默认的参数值“ 0 0 4px rgba(0,0,0,.3) ”。注：复杂的混合宏中的逻辑关系（@if…@else）后面小节会有讲解。\n混合宏-调用混合宏在 Sass 中通过 @mixin 关键词声明了一个混合宏，那么在实际调用中，其匹配了一个关键词“@include”来调用声明好的混合宏。例如在你的样式中定义了一个圆角的混合宏“border-radius”:\n1234@mixin border-radius&#123;    -webkit-border-radius: 3px;    border-radius: 3px;&#125;\n\n在一个按钮中要调用定义好的混合宏“border-radius”，可以这样使用：\n123button &#123;    @include border-radius;&#125;\n\n这个时候编译出来的 CSS:\n1234button &#123;  -webkit-border-radius: 3px;  border-radius: 3px;&#125;\n\n混合宏的参数–传一个不带值的参数Sass 的混合宏有一个强大的功能，可以传参，那么在 Sass 中传参主要有以下几种情形：\nA) 传一个不带值的参数在混合宏中，可以传一个不带任何值的参数，比如：\n1234@mixin border-radius($radius)&#123;  -webkit-border-radius: $radius;  border-radius: $radius;&#125;\n\n在混合宏“border-radius”中定义了一个不带任何值的参数“$radius”。在调用的时候可以给这个混合宏传一个参数值：\n123.box &#123;  @include border-radius(3px);&#125;\n\n这里表示给混合宏传递了一个“border-radius”的值为“3px”。编译出来的 CSS:\n1234.box &#123;  -webkit-border-radius: 3px;  border-radius: 3px;&#125;\n\n混合宏的参数–传一个带值的参数在 Sass 的混合宏中，还可以给混合宏的参数传一个默认值，例如：\n1234@mixin border-radius($radius:3px)&#123;  -webkit-border-radius: $radius;  border-radius: $radius;&#125;\n\n在混合宏“border-radius”传了一个参数“$radius”，而且给这个参数赋予了一个默认值“3px”。在调用类似这样的混合宏时，会多有一个机会，假设你的页面中的圆角很多地方都是“3px”的圆角，那么这个时候只需要调用默认的混合宏“border-radius”:\n123.btn &#123;  @include border-radius;&#125;\n\n编译出来的 CSS:\n1234.btn &#123;  -webkit-border-radius: 3px;  border-radius: 3px;&#125;\n\n但有的时候，页面中有些元素的圆角值不一样，那么可以随机给混合宏传值，如：\n123.box &#123;  @include border-radius(50%);&#125;\n\n编译出来的 CSS:\n1234.box &#123;  -webkit-border-radius: 50%;  border-radius: 50%;&#125;\n\n混合宏的参数–传多个参数Sass 混合宏除了能传一个参数之外，还可以传多个参数，如：\n123456789@mixin center($width,$height)&#123;  width: $width;  height: $height;  position: absolute;  top: 50%;  left: 50%;  margin-top: -($height) / 2;  margin-left: -($width) / 2;&#125;\n\n在混合宏“center”就传了多个参数。在实际调用和其调用其他混合宏是一样的：\n123.box-center &#123;  @include center(500px,300px);&#125;\n\n编译出来 CSS:\n123456789.box-center &#123;  width: 500px;  height: 300px;  position: absolute;  top: 50%;  left: 50%;  margin-top: -150px;  margin-left: -250px;&#125;\n\n  有一个特别的参数“…”。当混合宏传的参数过多之时，可以使用参数来替代，如：\n12345678910@mixin box-shadow($shadows...)&#123;  @if length($shadows) &gt;= 1 &#123;    -webkit-box-shadow: $shadows;    box-shadow: $shadows;  &#125; @else &#123;    $shadows: 0 0 2px rgba(#000,.25);    -webkit-box-shadow: $shadow;    box-shadow: $shadow;  &#125;&#125;\n\n在实际调用中：\n123.box &#123;  @include box-shadow(0 0 1px rgba(#000,.5),0 0 2px rgba(#000,.2));&#125;\n\n编译出来的CSS:\n1234.box &#123;  -webkit-box-shadow: 0 0 1px rgba(0, 0, 0, 0.5), 0 0 2px rgba(0, 0, 0, 0.2);  box-shadow: 0 0 1px rgba(0, 0, 0, 0.5), 0 0 2px rgba(0, 0, 0, 0.2);&#125;\n\n混合宏的参数–混合宏的不足混合宏在实际编码中给我们带来很多方便之处，特别是对于复用重复代码块。但其最大的不足之处是会生成冗余的代码块。比如在不同的地方调用一个相同的混合宏时。如：\n12345678910111213@mixin border-radius&#123;  -webkit-border-radius: 3px;  border-radius: 3px;&#125;.box &#123;  @include border-radius;  margin-bottom: 5px;&#125;.btn &#123;  @include border-radius;&#125;\n\n示例在“.box”和“.btn”中都调用了定义好的“border-radius”混合宏。先来看编译出来的 CSS：\n12345678910.box &#123;  -webkit-border-radius: 3px;  border-radius: 3px;  margin-bottom: 5px;&#125;.btn &#123;  -webkit-border-radius: 3px;  border-radius: 3px;&#125;\n\n上例明显可以看出，Sass 在调用相同的混合宏时，并不能智能的将相同的样式代码块合并在一起。这也是 Sass 的混合宏最不足之处。\n扩展/继承继承对于了解 CSS 的同学来说一点都不陌生，先来看一张图：\n图中代码显示“.col-sub .block li,.col-extra .block li” 继承了 “.item-list ul li”选择器的 “padding : 0;” 和 “ul li” 选择器中的 “list-style : none outside none;”以及 * 选择器中的 “box-sizing:inherit;”。在 Sass 中也具有继承一说，也是继承类中的样式代码块。在 Sass 中是通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。如下所示：\n123456789101112131415161718//SCSS.btn &#123;  border: 1px solid #ccc;  padding: 6px 10px;  font-size: 14px;&#125;.btn-primary &#123;  background-color: #f36;  color: #fff;  @extend .btn;&#125;.btn-second &#123;  background-color: orange;  color: #fff;  @extend .btn;&#125;\n\n编译出来之后：\n12345678910111213141516//CSS.btn, .btn-primary, .btn-second &#123;  border: 1px solid #ccc;  padding: 6px 10px;  font-size: 14px;&#125;.btn-primary &#123;  background-color: #f36;  color: #fff;&#125;.btn-second &#123;  background-clor: orange;  color: #fff;&#125;\n\n从示例代码可以看出，在 Sass 中的继承，可以继承类样式块中所有样式代码，而且编译出来的 CSS 会将选择器合并在一起，形成组合选择器：\n12345.btn, .btn-primary, .btn-second &#123;  border: 1px solid #ccc;  padding: 6px 10px;  font-size: 14px;&#125;\n\n占位符 %placeholderSass 中的占位符 %placeholder 功能是一个很强大，很实用的一个功能，这也是我非常喜欢的功能。他可以取代以前 CSS 中的基类造成的代码冗余的情形。因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码。来看一个演示：\n123456%mt5 &#123;  margin-top: 5px;&#125;%pt5&#123;  padding-top: 5px;&#125;\n\n这段代码没有被 @extend 调用，他并没有产生任何代码块，只是静静的躺在你的某个 SCSS 文件中。只有通过 @extend 调用才会产生代码：\n1234567891011121314151617181920//SCSS%mt5 &#123;  margin-top: 5px;&#125;%pt5&#123;  padding-top: 5px;&#125;.btn &#123;  @extend %mt5;  @extend %pt5;&#125;.block &#123;  @extend %mt5;  span &#123;    @extend %pt5;  &#125;&#125;\n\n编译出来的CSS\n12345678//CSS.btn, .block &#123;  margin-top: 5px;&#125;.btn, .block span &#123;  padding-top: 5px;&#125;\n\n从编译出来的 CSS 代码可以看出，通过 @extend 调用的占位符，编译出来的代码会将相同的代码合并在一起。这也是我们希望看到的效果，也让你的代码变得更为干净。\n混合宏 VS 继承 VS 占位符初学者都常常纠结于这个问题“什么时候用混合宏，什么时候用继承，什么时候使用占位符？”其实他们各有各的优点与缺点，先来看看他们使用效果：\na) Sass 中的混合宏使用举例代码见右侧 2-24 行编译出来的 CSS 见右侧结果窗口。总结：编译出来的 CSS 清晰告诉了大家，他不会自动合并相同的样式代码，如果在样式文件中调用同一个混合宏，会产生多个对应的样式代码，造成代码的冗余，这也是 CSSer 无法忍受的一件事情。不过他并不是一无事处，他可以传参数。\n个人建议：如果你的代码块中涉及到变量，建议使用混合宏来创建相同的代码块。\nb) Sass 中继承同样的，将上面代码中的混合宏，使用类名来表示，然后通过继承来调用：代码见右侧 26-48 行总结：使用继承后，编译出来的 CSS 会将使用继承的代码块合并到一起，通过组合选择器的方式向大家展现，比如 .mt, .block, .block span, .header, .header span。这样编译出来的代码相对于混合宏来说要干净的多，也是 CSSer 期望看到。但是他不能传变量参数。\n个人建议：如果你的代码块不需要专任何变量参数，而且有一个基类已在文件中存在，那么建议使用 Sass 的继承。\nc) 占位符最后来看占位符，将上面代码中的基类 .mt 换成 Sass 的占位符格式：代码见右侧 50-72 行\n总结：编译出来的 CSS 代码和使用继承基本上是相同，只是不会在代码中生成占位符 mt 的选择器。那么占位符和继承的主要区别的，“占位符是独立定义，不调用的时候是不会在 CSS 中产生任何代码；继承是首先有一个基类存在，不管调用与不调用，基类的样式都将会出现在编译出来的 CSS 代码中。”来看一个表格：\n插值#{}使用 CSS 预处理器语言的一个主要原因是想使用 Sass 获得一个更好的结构体系。比如说你想写更干净的、高效的和面向对象的 CSS。Sass 中的插值(Interpolation)就是重要的一部分。让我们看一下下面的例子：\n123456789$properties: (margin, padding);@mixin set-value($side, $value) &#123;    @each $prop in $properties &#123;        #&#123;$prop&#125;-#&#123;$side&#125;: $value;    &#125;&#125;.login-box &#123;    @include set-value(top, 14px);&#125;\n\n@each…in…语句会在《Sass进级篇》中 1-6 @each循环 中讲解。它可以让变量和属性工作的很完美，上面的代码编译成 CSS：\n1234.login-box &#123;    margin-top: 14px;    padding-top: 14px;&#125;\n\n这是 Sass 插值中一个简单的实例。当你想设置属性值的时候你可以使用字符串插入进来。另一个有用的用法是构建一个选择器。可以这样使用：\n123456@mixin generate-sizes($class, $small, $medium, $big) &#123;    .#&#123;$class&#125;-small &#123; font-size: $small; &#125;    .#&#123;$class&#125;-medium &#123; font-size: $medium; &#125;    .#&#123;$class&#125;-big &#123; font-size: $big; &#125;&#125;@include generate-sizes(\"header-text\", 12px, 20px, 40px);\n\n编译出来的 CSS:.\n123header-text-small &#123; font-size: 12px; &#125;.header-text-medium &#123; font-size: 20px; &#125;.header-text-big &#123; font-size: 40px; &#125;\n\n一旦你发现这一点，你就会想到超级酷的 mixins，用来生成代码或者生成另一个 mixins。然而，这并不完全是可能的。第一个限制，这可能会很删除用于 Sass 变量的插值。\n123456789$margin-big: 40px;$margin-medium: 20px;$margin-small: 12px;@mixin set-value($size) &#123;    margin-top: $margin-#&#123;$size&#125;;&#125;.login-box &#123;    @include set-value(big);&#125;\n\n上面的 Sass 代码编译出来，你会得到下面的信息：\n1error style.scss (Line 5: Undefined variable: “$margin-\".)\n\n所以，#{}语法并不是随处可用，你也不能在 mixin 中调用：\n12345678@mixin updated-status &#123;    margin-top: 20px;    background: #F00;&#125;$flag: \"status\";.navigation &#123;    @include updated-#&#123;$flag&#125;;&#125;\n\n上面的代码在编译成 CSS 时同样会报错：\n1error style.scss (Line 7: Invalid CSS after \"...nclude updated-\": expected \"&#125;\", was \"#&#123;$flag&#125;;\")\n\n幸运的是，可以使用 @extend 中使用插值。例如：\n123456789101112%updated-status &#123;    margin-top: 20px;    background: #F00;&#125;.selected-status &#123;    font-weight: bold;&#125;$flag: \"status\";.navigation &#123;    @extend %updated-#&#123;$flag&#125;;    @extend .selected-#&#123;$flag&#125;;&#125;\n\n上面的 Sass 代码是可以运行的，因为他给了我们力量，可以动态的插入 .class 和 %placeholder。当然他们不能接受像 mixin 这样的参数，上面的代码编译出来的 CSS:\n1234567.navigation &#123;    margin-top: 20px;    background: #F00;&#125;.selected-status, .navigation &#123;    font-weight: bold;&#125;\n\n注释注释对于一名程序员来说，是极其重要，良好的注释能帮助自己或者别人阅读源码。在 Sass 中注释有两种方式，我暂且将其命名为：\n\n类似 CSS 的注释方式，使用 ”/”开头，结属使用 ”/ ”\n类似 JavaScript 的注释方式，使用“//”两者区别，前者会在编译出来的 CSS 显示，后者在编译出来的 CSS 中不会显示，来看一个示例：\n\n1234567891011//定义一个占位符%mt5 &#123;  margin-top: 5px;&#125;/*调用一个占位符*/.box &#123;  @extend %mt5;&#125;\n\n编译出来的CSS\n12345.box &#123;  margin-top: 5px;&#125;/*调用一个占位符*/\n\n数据类型 Sass 和 JavaScript 语言类似，也具有自己的数据类型，在 Sass 中包含以下几种数据类型：\n\n数字: 如，1、 2、 13、 10px；\n字符串：有引号字符串或无引号字符串，如，”foo”、 ‘bar’、 baz；\n颜色：如，blue、 #04a3f9、 rgba(255,0,0,0.5)；\n布尔型：如，true、 false；\n空值：如，null；\n值列表：用空格或者逗号分开，如，1.5em 1em 0 2em 、 Helvetica, Arial, sans-serif。\n\nSassScript 也支持其他 CSS 属性值（property value），比如 Unicode 范围，或 !important 声明。然而，Sass 不会特殊对待这些属性值，一律视为无引号字符串 (unquoted strings)。\n字符串SassScript 支持 CSS 的两种字符串类型：\n\n有引号字符串 (quoted strings)，如 “Lucida Grande” 、’http://sass-lang.com&#39;；\n无引号字符串 (unquoted strings)，如 sans-serifbold。在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{ }插值语句 (interpolation) 时，有引号字符串将被编译为无引号字符串，这样方便了在混合指令 (mixin) 中引用选择器名。\n\n123456@mixin firefox-message($selector) &#123;  body.firefox #&#123;$selector&#125;:before &#123;    content: \"Hi, Firefox users!\";  &#125;&#125;@include firefox-message(\".header\");\n\n编译为：\n12body.firefox .header:before &#123;  content: \"Hi, Firefox users!\"; &#125;\n\n需要注意的是：当 deprecated = property syntax 时 （暂时不理解是怎样的情况），所有的字符串都将被编译为无引号字符串，不论是否使用了引号。\n值列表所谓值列表 (lists) 是指 Sass 如何处理 CSS 中：margin: 10px 15px 0 0\n12\n\n或者：\n1font-face: Helvetica, Arial, sans-serif\n\n像上面这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为值列表——只包含一个值的值列表。\nSass列表函数（Sass list functions）赋予了值列表更多功能（Sass进级会有讲解）：\n\nnth函数（nth function） 可以直接访问值列表中的某一项；\njoin函数（join function） 可以将多个值列表连结在一起；\nappend函数（append function） 可以在值列表中添加值；\n@each规则（@each rule） 则能够给值列表中的每个项目添加样式。\n\n值列表中可以再包含值列表，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个值列表的值列表。如果内外两层值列表使用相同的分隔方式，要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。当值列表被编译为 CSS 时，Sass 不会添加任何圆括号，因为 CSS 不允许这样做。(1px 2px) (5px 6px)与 1px 2px 5px 6px 在编译后的 CSS 文件中是一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个值列表的值列表，而后者是包含四个值的值列表。\n可以用 () 表示空的列表，这样不可以直接编译成 CSS，比如编译 font-family: ()时，Sass 将会报错。如果值列表中包含空的值列表或空值，编译时将清除空值，比如 1px 2px () 3px 或 1px 2px null 3px。\n[Sass运算]加法程序中的运算是常见的一件事情，但在 CSS 中能做运算的，到目前为止仅有 calc() 函数可行。但在 Sass 中，运算只是其基本特性之一。在 Sass 中可以做各种数学计算，在接下来的章节中，主要和大家一起探讨有关于 Sass 中的数学运算。\n（一）、加法加法运算是 Sass 中运算中的一种，在变量或属性中都可以做加法运算。如：\n123.box &#123;  width: 20px + 8in;&#125;\n\n编译出来的 CSS:\n123.box &#123;  width: 788px;&#125;\n\n但对于携带不同类型的单位时，在 Sass 中计算会报错，如下例所示：\n123.box &#123;  width: 20px + 1em;&#125;\n\n编译的时候，编译器会报错：“Incompatible units: ‘em’ and ‘px’.”in mm cm  pt pc px等绝对单位都能运算ex em rem等相对当前字体的都不能运算\n[Sass运算]减法Sass 的减法运算和加法运算类似，我们通过一个简单的示例来做阐述：\n123456$full-width: 960px;$sidebar-width: 200px;.content &#123;  width: $full-width -  $sidebar-width;&#125;\n\n编译出来的 CSS 如下：\n123.content &#123;  width: 760px;&#125;\n\n同样的，运算时碰到不同类型的单位时，编译也会报错，如：\n12345$full-width: 960px;.content &#123;  width: $full-width -  1em;&#125;\n\n编译的时候，编译器报“Incompatible units: ‘em’ and ‘px’.”错误。\n[Sass运算]乘法Sass 中的乘法运算和前面介绍的加法与减法运算还略有不同。虽然他也能够支持多种单位（比如 em ,px , %），但当一个单位同时声明两个值时会有问题。比如下面的示例：\n123.box &#123;  width:10px * 2px;  &#125;\n\n编译的时候报“20px*px isn’t a valid CSS value.”错误信息。如果进行乘法运算时，两个值单位相同时，只需要为一个数值提供单位即可。上面的示例可以修改成：\n123.box &#123;  width: 10px * 2;&#125;\n\n编译出来的 CSS:\n123.box &#123;  width: 20px;&#125;\n\nSass 的乘法运算和加法、减法运算一样，在运算中有不同类型的单位时，也将会报错。如下面的示例：\n123.box &#123;  width: 20px * 2em;&#125;\n\n编译时报“40em*px isn’t a valid CSS value.”错误信息。\n[Sass运算]除法Sass 的乘法运算规则也适用于除法运算。不过除法运算还有一个特殊之处。众所周知“/”符号在 CSS 中已做为一种符号使用。因此在 Sass 中做除法运算时，直接使用“/”符号做为除号时，将不会生效，编译时既得不到我们需要的效果，也不会报错。一起先来看一个简单的示例：\n123.box &#123;  width: 100px / 2;  &#125;\n\n编译出来的 CSS 如下：\n123.box &#123;  width: 100px / 2;&#125;\n\n这样的结果对于大家来说没有任何意义。要修正这个问题，只需要给运算的外面添加一个小括号( )即可：\n123.box &#123;  width: (100px / 2);  &#125;\n\n编译出来的 CSS 如下：\n123.box &#123;  width: 50px;&#125;\n\n除了上面情况带有小括号，“/”符号会当作除法运算符之外，如果“/”符号在已有的数学表达式中时，也会被认作除法符号。如下面示例：\n123.box &#123;  width: 100px / 2 + 2in;  &#125;\n\n编译出来的CSS：\n123.box &#123;  width: 242px;&#125;\n\n另外，在 Sass 除法运算中，当用变量进行除法运算时，“/”符号也会自动被识别成除法，如下例所示：\n12345678910$width: 1000px;$nums: 10;.item &#123;  width: $width / 10;  &#125;.list &#123;  width: $width / $nums;&#125;\n\n编译出来的CSS:\n1234567.item &#123;  width: 100px;&#125;.list &#123;  width: 100px;&#125;\n\n综合上述，”/  ”符号被当作除法运算符时有以下几种情况：\n\n•    如果数值或它的任意部分是存储在一个变量中或是函数的返回值。\n•    如果数值被圆括号包围。\n•    如果数值是另一个数学表达式的一部分。如下所示：\n\n123456789//SCSSp &#123;  font: 10px/8px;             // 纯 CSS，不是除法运算  $width: 1000px;  width: $width/2;            // 使用了变量，是除法运算  width: round(1.5)/2;        // 使用了函数，是除法运算  height: (500px/2);          // 使用了圆括号，是除法运算  margin-left: 5px + 8px/2px; // 使用了加（+）号，是除法运算&#125;\n\n编译出来的CSS\n123456p &#123;  font: 10px/8px;  width: 500px;  height: 250px;  margin-left: 9px; &#125;\n\nSass 的除法运算还有一个情况。我们先回忆一下，在乘法运算时，如果两个值带有相同单位时，做乘法运算时，出来的结果并不是我们需要的结果。但在除法运算时，如果两个值带有相同的单位值时，除法运算之后会得到一个不带单位的数值。如下所示：\n123.box &#123;  width: (1000px / 100px);&#125;\n\n编译出来的CSS如下：\n123.box &#123;  width: 10;&#125;\n\n[Sass运算]变量计算在 Sass 中除了可以使用数值进行运算之外，还可以使用变量进行计算，其实在前面章节的示例中也或多或少的向大家展示了。在 Sass 中使用变量进行计算，这使得 Sass 的数学运算功能变得更加实用。一起来看一个简单的示例：\n12345678$content-width: 720px;$sidebar-width: 220px;$gutter: 20px;.container &#123;  width: $content-width + $sidebar-width + $gutter;  margin: 0 auto;&#125;\n\n编译出来的CSS\n1234.container &#123;  width: 960px;  margin: 0 auto;&#125;\n\n[Sass运算]数字运算在 Sass 运算中数字运算是较为常见的，数字运算包括前面介绍的：加法、减法、乘法和除法等运算。而且还可以通过括号来修改他们的运算先后顺序。和我们数学运算是一样的，一起来看个示例。\n123.box &#123;  width: ((220px + 720px) - 11 * 20 ) / 12 ;  &#125;\n\n编译出来的 CSS:\n123.box &#123;  width: 60px;&#125;\n\n上面这个简单示例是一个典型的计算 Grid 单列列宽的运算。\n[Sass运算]颜色运算所有算数运算都支持颜色值，并且是分段运算的。也就是说，红、绿和蓝各颜色分段单独进行运算。如：\n123p &#123;  color: #010203 + #040506;&#125;\n\n计算公式为 01 + 04 = 05、02 + 05 = 07 和 03 + 06 = 09， 并且被合成为：如此编译出来的 CSS 为：\n123p &#123;  color: #050709;&#125;\n\n算数运算也能将数字和颜色值 一起运算，同样也是分段运算的。如：\n123p &#123;  color: #010203 * 2;&#125;\n\n计算公式为 01 2 = 02、02 2 = 04 和 03 * 2 = 06， 并且被合成为：\n123p &#123;  color: #020406;&#125;\n\n[Sass运算]字符运算在 Sass 中可以通过加法符号“+”来对字符串进行连接。例如：\n1234$content: &quot;Hello&quot; + &quot;&quot; + &quot;Sass!&quot;;.box:before &#123;  content: &quot; #&#123;$content&#125; &quot;;&#125;\n\n编译出来的CSS：\n123.box:before &#123;  content: &quot; Hello Sass! &quot;;&#125;\n\n除了在变量中做字符连接运算之外，还可以直接通过 +，把字符连接在一起：\n1234567div &#123;  cursor: e + -resize;&#125;编译出来的CSS:div &#123;  cursor: e-resize;&#125;\n\n注意，如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 例如：\n1234p:before &#123;  content: &quot;Foo &quot; + Bar;  font-family: sans- + &quot;serif&quot;;&#125;\n\n编译出来的 CSS：\n123p:before &#123;  content: &quot;Foo Bar&quot;;  font-family: sans-serif; &#125;\n\nSASS指令@if@if 指令是一个 SassScript，它可以根据条件来处理样式块，如果条件为 true 返回一个样式块，反之 false 返回另一个样式块。在 Sass 中除了 @if 之，还可以配合 @else if 和 @else 一起使用。假设要控制一个元素隐藏或显示，我们就可以定义一个混合宏，通过 @if…@else… 来判断传进参数的值来控制 display 的值。如下所示：\n12345678910111213141516171819//SCSS@mixin blockOrHidden($boolean:true) &#123;  @if $boolean &#123;      @debug &quot;$boolean is #&#123;$boolean&#125;&quot;;      display: block;    &#125;  @else &#123;      @debug &quot;$boolean is #&#123;$boolean&#125;&quot;;      display: none;    &#125;&#125;.block &#123;  @include blockOrHidden;&#125;.hidden&#123;  @include blockOrHidden(false);&#125;\n\n编译出来的CSS:\n1234567.block &#123;  display: block;&#125;.hidden &#123;  display: none;&#125;\n\n@for循环（上）在制作网格系统的时候，大家应该对 .col1~.col12 这样的印象较深。在 CSS 中你需要一个一个去书写，但在 Sass 中，可以使用 @for 循环来完成。在 Sass 的 @for 循环中有两种方式：\n12@for $i from &lt;start&gt; through &lt;end&gt;@for $i from &lt;start&gt; to &lt;end&gt;\n\n\n$i 表示变量\nstart 表示起始值\nend 表示结束值这两个的区别是关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。如下代码，先来个使用 through 关键字的例子：\n\n123@for $i from 1 through 3 &#123;  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;\n\n编译出来的 CSS:\n1234567891011.item-1 &#123;  width: 2em;&#125;.item-2 &#123;  width: 4em;&#125;.item-3 &#123;  width: 6em;&#125;\n\n再来个 to 关键字的例子：@for $i from 1 to 3 {  .item-#{$i} { width: 2em * $i; }}编译出来的 CSS:\n1234567.item-1 &#123;  width: 2em;&#125;.item-2 &#123;  width: 4em;&#125;\n\n@for循环 （下）上一小节的那个实例几乎用不着，哈哈，所以其实是没什么营养的东西，只是帮助理解了原来 @for 是这么回事。怎么的也不能就这么忽悠大家啊，大家好不容易抽空看下文章，就这么点扯淡的东西怎么对得住呢。下面再来个营养级别的，@for应用在网格系统生成各个格子 class 的代码：\n12345678910111213141516//SCSS $grid-prefix: span !default;$grid-width: 60px !default;$grid-gutter: 20px !default;%grid &#123;  float: left;  margin-left: $grid-gutter / 2;  margin-right: $grid-gutter / 2;&#125;@for $i from 1 through 12 &#123;  .#&#123;$grid-prefix&#125;#&#123;$i&#125;&#123;    width: $grid-width * $i + $grid-gutter * ($i - 1);    @extend %grid;  &#125;  &#125;\n\n编译出来的 CSS:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.span1, .span2, .span3, .span4, .span5, .span6, .span7, .span8, .span9, .span10, .span11, .span12 &#123;  float: left;  margin-left: 10px;  margin-right: 10px;&#125;.span1 &#123;  width: 60px;&#125;.span2 &#123;  width: 140px;&#125;.span3 &#123;  width: 220px;&#125;.span4 &#123;  width: 300px;&#125;.span5 &#123;  width: 380px;&#125;.span6 &#123;  width: 460px;&#125;.span7 &#123;  width: 540px;&#125;.span8 &#123;  width: 620px;&#125;.span9 &#123;  width: 700px;&#125;.span10 &#123;  width: 780px;&#125;.span11 &#123;  width: 860px;&#125;.span12 &#123;  width: 940px;&#125;\n\n将上面的示例稍做修改，将 @for through 方式换成 @for to:：\n1234567//SCSS@for $i from 1 to 13 &#123;  .#&#123;$grid-prefix&#125;#&#123;$i&#125;&#123;    width: $grid-width * $i + $grid-gutter * ($i - 1);    @extend %grid;  &#125;  &#125;\n\n其最终编译出来的 CSS 代码和上例所编译出来的一模一样。这两段 Sass 代码并无太多差别，只是 @for中的  取值不同。配合 through 的  值是 12，其遍历出来的终点值也是 12，和  值一样。配合 to 的  值是 13，其遍历出来的终点值是 12，就是  对就的值减去 1 。\n@while循环@while 指令也需要 SassScript 表达式（像其他指令一样），并且会生成不同的样式块，直到表达式值为 false 时停止循环。这个和 @for 指令很相似，只要 @while 后面的条件为 true 就会执行。这里有一个 @while 指令的简单用例：\n12345678910//SCSS$types: 4;$type-width: 20px;@while $types &gt; 0 &#123;    .while-#&#123;$types&#125; &#123;        width: $type-width + $types;    &#125;    $types: $types - 1;&#125;\n\n编译出来的 CSS\n123456789101112131415.while-4 &#123;  width: 24px;&#125;.while-3 &#123;  width: 23px;&#125;.while-2 &#123;  width: 22px;&#125;.while-1 &#123;  width: 21px;&#125;\n\n@each循环@each 循环就是去遍历一个列表，然后从列表中取出对应的值。@each 循环指令的形式：\n1@each $var in &lt;list&gt;\n\n如果你没有接触过列表，也不要紧，他也非常简单。在下面的例子中你可以看到，$var 就是一个变量名， 是一个 SassScript 表达式，他将返回一个列表值。变量 $var 会在列表中做遍历，并且遍历出与 $var 对应的样式块。这有一个 @each 指令的简单示例：\n1$list: adam john wynn mason kuroir;//$list\n\n 就是一个列表\n1234567891011@mixin author-images &#123;    @each $author in $list &#123;        .photo-#&#123;$author&#125; &#123;            background: url(&quot;/images/avatars/#&#123;$author&#125;.png&quot;) no-repeat;        &#125;    &#125;&#125;.author-bio &#123;    @include author-images;&#125;\n\n编译出 CSS:.\n12345678910author-bio .photo-adam &#123;  background: url(&quot;/images/avatars/adam.png&quot;) no-repeat; &#125;.author-bio .photo-john &#123;  background: url(&quot;/images/avatars/john.png&quot;) no-repeat; &#125;.author-bio .photo-wynn &#123;  background: url(&quot;/images/avatars/wynn.png&quot;) no-repeat; &#125;.author-bio .photo-mason &#123;  background: url(&quot;/images/avatars/mason.png&quot;) no-repeat; &#125;.author-bio .photo-kuroir &#123;  background: url(&quot;/images/avatars/kuroir.png&quot;) no-repeat; &#125;\n\nSASS函数Sass的函数简介在 Sass 中除了可以定义变量，具有 @extend、%placeholder 和 mixins 等特性之外，还自备了一系列的函数功能。其主要包括：\n\n字符串函数\n数字函数\n列表函数\n颜色函数\nIntrospection 函数\n三元函数等\n\n-当然除了自备的函数功能之外，我们还可以根据自己的需求定义函数功能，常常称之为自定义函数。\n字符串函数-unquote()函数字符串函数顾名思意是用来处理字符串的函数。Sass 的字符串函数主要包括两个函数：\n12unquote($string)：删除字符串中的引号；      quote($string)：给字符串添加引号。\n\n1、unquote()函数\nunquote() 函数主要是用来删除一个字符串中的引号，如果这个字符串没有带有引号，将返回原始的字符串。简单的使用终端来测试这个函数的运行结果：\n12345678910111213141516171819//SCSS.test1 &#123;    content:  unquote(&apos;Hello Sass!&apos;) ;&#125;.test2 &#123;    content: unquote(&quot;&apos;Hello Sass!&quot;);&#125;.test3 &#123;    content: unquote(&quot;I&apos;m Web Designer&quot;);&#125;.test4 &#123;    content: unquote(&quot;&apos;Hello Sass!&apos;&quot;);&#125;.test5 &#123;    content: unquote(&apos;&quot;Hello Sass!&quot;&apos;);&#125;.test6 &#123;    content: unquote(Hello Sass);&#125;\n\n编译后的 css 代码：\n123456789101112131415161718//CSS.test1 &#123;  content: Hello Sass!; &#125;.test2 &#123;  content: &apos;Hello Sass!; &#125;.test3 &#123;  content: I&apos;m Web Designer; &#125;.test4 &#123;  content: &apos;Hello Sass!&apos;; &#125;.test5 &#123;  content: &quot;Hello Sass!&quot;; &#125;.test6 &#123;  content: Hello Sass; &#125;\n\n注意：从测试的效果中可以看出，unquote( ) 函数只能删除字符串最前和最后的引号（双引号或单引号），而无法删除字符串中间的引号。如果字符没有带引号，返回的将是字符串本身。\n字符串函数-quote()函数quote() 函数刚好与 unquote() 函数功能相反，主要用来给字符串添加引号。如果字符串，自身带有引号会统一换成双引号 “”。如：\n12345678910111213//SCSS.test1 &#123;    content:  quote(&apos;Hello Sass!&apos;);&#125;.test2 &#123;    content: quote(&quot;Hello Sass!&quot;);&#125;.test3 &#123;    content: quote(ImWebDesigner);&#125;.test4 &#123;    content: quote(&apos; &apos;);&#125;\n\n编译出来的 css 代码：\n12345678910111213//CSS.test1 &#123;  content: &quot;Hello Sass!&quot;;&#125;.test2 &#123;  content: &quot;Hello Sass!&quot;;&#125;.test3 &#123;  content: &quot;ImWebDesigner&quot;;&#125;.test4 &#123;  content: &quot;&quot;;&#125;\n\n使用 quote() 函数只能给字符串增加双引号，而且字符串中间有单引号或者空格时，需要用单引号或双引号括起，否则编译的时候将会报错。\n123456.test1 &#123;    content:  quote(Hello Sass);&#125;这样使用，编译器马上会报错：error style.scss (Line 13: $string: (&quot;Hello&quot;&quot;Sass&quot;) is not a string for `quote&apos;)\n\n解决方案就是去掉空格，或者加上引号：\n123456.test1 &#123;    content:  quote(HelloSass);&#125;.test1 &#123;    content:  quote(&quot;Hello Sass&quot;);&#125;\n\n同时 quote() 碰到特殊符号，比如： !、?、&gt; 等，除中折号 - 和 下划线_ 都需要使用双引号括起，否则编译器在进行编译的时候同样会报错：\n12error style.scss (Line 13: Invalid CSS after &quot;...quote(HelloSass&quot;: expected &quot;)&quot;, was &quot;!);&quot;)error style.scss (Line 16: Invalid CSS after &quot;...t:  quote(Hello&quot;: expected &quot;)&quot;, was “?);&quot;)\n\n字符串函数-To-upper-case()、To-lower-case()1、To-upper-case()To-upper-case() 函数将字符串小写字母转换成大写字母。如：\n12345//SCSS.test &#123;  text: to-upper-case(aaaaa);  text: to-upper-case(aA-aAAA-aaa);&#125;\n\n编译出来的 css 代码：\n12345//CSS.test &#123;  text: AAAAA;  text: AA-AAAA-AAA;&#125;\n\n2、To-lower-case()To-lower-case() 函数 与 To-upper-case() 刚好相反，将字符串转换成小写字母：\n12345//SCSS.test &#123;  text: to-lower-case(AAAAA);  text: to-lower-case(aA-aAAA-aaa);&#125;\n\n编译出来的 css 代码：\n12345//CSS.test &#123;  text: aaaaa;  text: aa-aaaa-aaa;&#125;\n\n数字函数简介Sass 中的数字函数提要针对数字方面提供一系列的函数功能：\n\npercentage($value)：将一个不带单位的数转换成百分比值；\nround($value)：将数值四舍五入，转换成一个最接近的整数；\nceil($value)：将大于自己的小数转换成下一位整数；\nfloor($value)：将一个数去除他的小数部分；\nabs($value)：返回一个数的绝对值；\nmin($numbers…)：找出几个数值之间的最小值；\nmax($numbers…)：找出几个数值之间的最大值；\nrandom(): 获取随机数\n\n看到上面函数的简介，对于熟悉Javascript 同学而言并不会感觉陌生。因为他们有很多功能都非常类似，接下来对每个函数进行一些简单的测试 。\n数字函数-percentage()1、percentage()\npercentage()函数主要是将一个不带单位的数字转换成百分比形式：\n123456789101112&gt;&gt; percentage(.2)20%&gt;&gt; percentage(2px / 10px)20%&gt;&gt; percentage(2em / 10em)20%&gt;&gt; .footer&#123;    width : percentage(.2)&#125;\n\n编译后的 css 代码：\n123.footer&#123;    width : 20%&#125;\n\n如果您转换的值是一个带有单位的值，那么在编译的时候会报错误信息：\n12&gt;&gt; percentage(2px / 10em)SyntaxError: $value: 0.2px/em is not a unitless number for `percentage&apos;\n\n数字函数-round()函数round() 函数可以将一个数四舍五入为一个最接近的整数：\n123456789101112131415161718192021222324252627&gt;&gt; round(12.3)12&gt;&gt; round(12.5)13&gt;&gt; round(1.49999)1&gt;&gt; round(2.0)2&gt;&gt; round(20%)20%&gt;&gt; round(2.2%)2%&gt;&gt; round(3.9em)4em&gt;&gt; round(2.3px)2px&gt;&gt; round(2px / 3px)1&gt;&gt; round(1px / 3px)0&gt;&gt; round(3px / 2em)2px/em .footer &#123;   width:round(12.3px)&#125;\n\n12345编译后的 css 代码：.footer &#123;  width: 12px;&#125;\n\n在round() 函数中可以携带单位的任何数值。\n数字函数-ceil()函数ceil() 函数将一个数转换成最接近于自己的整数，会将一个大于自身的任何小数转换成大于本身 1 的整数。也就是只做入，不做舍的计算：\n1234567891011121314151617181920212223&gt;&gt; ceil(2.0)2&gt;&gt; ceil(2.1)3&gt;&gt; ceil(2.6)3&gt;&gt; ceil(2.3%)3%&gt;&gt; ceil(2.3px)3px&gt;&gt; ceil(2.5px)3px&gt;&gt; ceil(2px / 3px)1&gt;&gt; ceil(2% / 3px)1%/px&gt;&gt; ceil(1em / 5px)1em/px .footer &#123;   width:ceil(12.3px);&#125;\n\n编译后的 css 代码：\n123.footer &#123;  width: 13px;&#125;\n\n数字函数-floor()函数floor() 函数刚好与 ceil() 函数功能相反，其主要将一个数去除其小数部分，并且不做任何的进位。也就是只做舍，不做入的计算：\n12345678910111213141516171819&gt;&gt; floor(2.1)2&gt;&gt; floor(2.5)2&gt;&gt; floor(3.5%)3%&gt;&gt; floor(10.2px)10px&gt;&gt; floor(10.8em)10em&gt;&gt; floor(2px / 10px)0&gt;&gt; floor(3px / 1em)3px/em .footer &#123;   width:floor(12.3px);&#125;\n\n编译后的 css 代码：\n123.footer &#123;  width: 12px;&#125;\n\n数字函数-abs()函数abs( ) 函数会返回一个数的绝对值。\n1234567891011121314151617&gt;&gt; abs(10)10&gt;&gt; abs(-10)10&gt;&gt; abs(-10px)10px&gt;&gt; abs(-2em)2em&gt;&gt; abs(-.5%)0.5%&gt;&gt; abs(-1px / 2px)0.5 .footer &#123;   width:abs(-12.3px);&#125;\n\n编译后的 css 代码：\n123.footer &#123;  width: 12.3px;&#125;\n\n数字函数-min()函数、max()函数min()函数min() 函数功能主要是在多个数之中找到最小的一个，这个函数可以设置任意多个参数：\n123456&gt;&gt; min(1,2,1%,3,300%)1%&gt;&gt; min(1px,2,3px)1px&gt;&gt; min(1em,2em,6em)1em\n\n不过在 min() 函数中同时出现两种不同类型的单位，将会报错误信息：\n12&gt;&gt; min(1px,1em)SyntaxError: Incompatible units: &apos;em&apos; and &apos;px&apos;.\n\nmax()函数max() 函数和 min() 函数一样，不同的是，max() 函数用来获取一系列数中的最大那个值：\n1234&gt;&gt; max(1,5)5&gt;&gt; max(1px,5px)5px\n\n同样的，如果在 max() 函数中有不同单位，将会报错：\n12&gt;&gt; max(1,3px,5%,6)SyntaxError: Incompatible units: &apos;%&apos; and ‘px&apos;.\n\n数字函数-random()函数random() 函数是用来获取一个随机数：\n12345678910&gt;&gt; random()0.03886&gt;&gt; random()0.66527&gt;&gt; random()0.8125&gt;&gt; random()0.26839&gt;&gt; random()0.85063\n\n列表函数简介列表函数主要包括一些对列表参数的函数使用，主要包括以下几种：\n\nlength($list)：返回一个列表的长度值；\nnth($list, $n)：返回一个列表中指定的某个标签值\njoin($list1, $list2, [$separator])：将两个列给连接在一起，变成一个列表；\nappend($list1, $val, [$separator])：将某个值放在列表的最后；\nzip($lists…)：将几个列表结合成一个多维的列表；\nindex($list, $value)：返回一个值在列表中的位置值。\n\n列表函数中的每个函数都有其独特的作用与功能，接下来我们通过命令终端向大家展示每个列表函数的功能与使用。\nlength()函数length() 函数主要用来返回一个列表中有几个值，简单点说就是返回列表清单中有多少个值：\n123456&gt;&gt; length(10px)1&gt;&gt; length(10px 20px (border 1px solid) 2em)4&gt;&gt; length(border 1px solid)3\n\nlength() 函数中的列表参数之间使用空格隔开，不能使用逗号，否则函数将会出错：\n1234&gt;&gt; length(10px,20px,(border 1px solid),2em)SyntaxError: wrong number of arguments (4 for 1) for `length&apos;&gt;&gt; length(1,2px)SyntaxError: wrong number of arguments (2 for 1) for `length&apos;\n\nnth()函数语法:\n1nth($list,$n)\n\nnth() 函数用来指定列表中某个位置的值。不过在 Sass 中，nth() 函数和其他语言不同，1 是指列表中的第一个标签值，2 是指列给中的第二个标签值，依此类推。如：\n123456&gt;&gt; nth(10px 20px 30px,1)10px&gt;&gt; nth((Helvetica,Arial,sans-serif),2)&quot;Arial&quot;&gt;&gt; nth((1px solid red) border-top green,1)(1px &quot;solid&quot; #ff0000)\n\n注：在 nth($list,$n) 函数中的 $n 必须是大于 0 的整数：\n12&gt;&gt; nth((1px solid red) border-top green 1 ,0)SyntaxError: List index 0 must be a non-zero integer for `nth&apos;\n\njoin()函数join() 函数是将两个列表连接合并成一个列表。\n123456&gt;&gt; join(10px 20px, 30px 40px)(10px 20px 30px 40px)&gt;&gt; join((blue,red),(#abc,#def))(#0000ff, #ff0000, #aabbcc, #ddeeff)&gt;&gt; join((blue,red),(#abc #def))(#0000ff, #ff0000, #aabbcc, #ddeeff)\n\n不过 join() 只能将两个列表连接成一个列表，如果直接连接两个以上的列表将会报错：\n12&gt;&gt; join((blue red),(#abc, #def),(#dee #eff))SyntaxError: $separator: (#ddeeee #eeffff) is not a string for `join&apos;\n\n但很多时候不只碰到两个列表连接成一个列表，这个时候就需要将多个 join() 函数合并在一起使用：\n12&gt;&gt; join((blue red), join((#abc #def),(#dee #eff)))(#0000ff #ff0000 #aabbcc #ddeeff #ddeeee #eeffff)\n\n在 join() 函数中还有一个很特别的参数 $separator，这个参数主要是用来给列表函数连接列表值是，使用的分隔符号，默认值为 auto。\njoin() 函数中 $separator 除了默认值 auto 之外，还有 comma 和 space 两个值，其中 comma 值指定列表中的列表项值之间使用逗号（,）分隔，space 值指定列表中的列表项值之间使用空格（ ）分隔。\n在 join() 函数中除非明确指定了 $separator值，否则将会有多种情形发生：\n如果列表中的第一个列表中每个值之间使用的是逗号（,），那么 join() 函数合并的列表中每个列表项之间使用逗号,分隔：\n12&gt;&gt; join((blue, red, #eff),(green orange))(#0000ff, #ff0000, #eeffff, #008000, #ffa500)\n\n但当第一个列表中只有一个列表项，那么 join() 函数合并的列表项目中每个列表项目这间使用的分隔符号会根据第二个列表项中使用的，如果第二列表项中使用是,分隔，则使用逗号分隔；如果第二列项之间使用的空格符，则使用空格分隔：\n1234&gt;&gt; join(blue,(green, orange))(#0000ff, #008000, #ffa500)&gt;&gt; join(blue,(green orange))(#0000ff #008000 #ffa500)\n\n如果列表中的第一个列表中每个值之间使用的是空格，那么 join() 函数合并的列表中每个列表项之间使用空格分隔：\n1234&gt;&gt; join((blue green),(red,orange))(#0000ff #008000 #ff0000 #ffa500)&gt;&gt; join((blue green),(red orange))(#0000ff #008000 #ff0000 #ffa500)\n\n如果当两个列表中的列表项小于1时，将会以空格分隔：\n12&gt;&gt; join(blue,red)(#0000ff #ff0000)\n\n如此一来，会有多种情形发生，造成使用混乱的情形，如果你无法记得，什么时候会是用逗号分隔合并的列表项，什么时候是使用空格分隔合并 的列表项，在些建议大家使用 join() 函数合并列表项的时候就明确指定 $separator 参数，用来指定合并的列表中使用什么方式来分隔列表项：\n1234567891011121314151617181920&gt;&gt; join(blue,red,comma)(#0000ff, #ff0000)&gt;&gt; join(blue,red,space)(#0000ff #ff0000)&gt;&gt; join((blue green),(red,orange),comma)(#0000ff, #008000, #ff0000, #ffa500)&gt;&gt; join((blue green),(red,orange),space)(#0000ff #008000 #ff0000 #ffa500)&gt;&gt; join((blue, green),(red,orange),comma)(#0000ff, #008000, #ff0000, #ffa500)&gt;&gt; join((blue, green),(red,orange),space)(#0000ff #008000 #ff0000 #ffa500)&gt;&gt; join(blue,(red,orange),comma)(#0000ff, #ff0000, #ffa500)&gt;&gt; join(blue,(red,orange),space)(#0000ff #ff0000 #ffa500)&gt;&gt; join(blue,(red orange),comma)(#0000ff, #ff0000, #ffa500)&gt;&gt; join(blue,(red orange),space)(#0000ff #ff0000 #ffa500)\n\nappend()函数append() 函数是用来将某个值插入到列表中，并且处于最末位。\n12345678&gt;&gt; append(10px 20px ,30px)(10px 20px 30px)&gt;&gt; append((10px,20px),30px)(10px, 20px, 30px)&gt;&gt; append(green,red)(#008000 #ff0000)&gt;&gt; append(red,(green,blue))(#ff0000 (#008000, #0000ff))\n\n如果没有明确的指定 $separator 参数值，其默认值是 auto。\n如果列表只有一个列表项时，那么插入进来的值将和原来的值会以空格的方式分隔。如果列表中列表项是以空格分隔列表项，那么插入进来的列表项也将以空格分隔；如果列表中列表项是以逗号分隔列表项，那么插入进来的列表项也将以逗号分隔。当然，在 append() 函数中，可以显示的设置 $separator 参数，\n如果取值为 comma 将会以逗号分隔列表项如果取值为 space 将会以空格分隔列表项\n123456789101112&gt;&gt; append((blue green),red,comma)(#0000ff, #008000, #ff0000)&gt;&gt; append((blue green),red,space)(#0000ff #008000 #ff0000)&gt;&gt; append((blue, green),red,comma)(#0000ff, #008000, #ff0000)&gt;&gt; append((blue, green),red,space)(#0000ff #008000 #ff0000)&gt;&gt; append(blue,red,comma)(#0000ff, #ff0000)&gt;&gt; append(blue,red,space)(#0000ff #ff0000)\n\n","plink":"https://yanoo1497.github.io/post/sass学习笔记/"},{"title":"《css世界》书摘","date":"2017-04-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.370Z","content":"\n选择器的种类：基础选择器 + 关系型选择器\n标签的分类：\n\n\n块级元素和内联元素 （！块级元素并不等于display : block,例如 li 元素的 display 值为 list-item ，table 元素则为 table）;\n\n-\n\nIE 浏览器无法支持 list-item 的原因：无法生成外部防止圆点标记的盒子；\n所有盒子都由两种盒子结构组成，块级盒子（负责结构）内联盒子（负责内容）。内联元素（inline-block）即为外层内联盒子内层块级盒子。\nwidth: auto 的作用\n\n\n充分利用可用空间；\n收缩与包裹；\n收缩到最小；\n超出容器限制；（只要不指定宽度又没有设置 whit-space:nowrap 是不会超出容器边界的）\n\n\n要充分利用浏览器原生流特性的好处\n\n\nbutton 按钮和 input 按钮的区别：\n\n\nbutton 按钮标签文字会自动换行，input 标签按钮因为有 white-space:pre 不会自动换行，改值为 normal 则可以换行；\n\n\n需求：模块内的文字是动态的，要求文字少的时候居中显示，文字超出一行时居左显示 。\n\n12.box &#123; text-align: center&#125;;// 外部容器盒子.content &#123; display: inline-block; // 内部文本盒子 text-align:left&#125;\n\n\nwidth 是作用在 content box 上面的（或许是因为 width 是CSS2.1 制定的，而 CSS2.1 是面向内容设计的），而浏览器对于 content box 的尺寸定义不一致（是否包括 padding、border不一样，因而会有宽度计算问题），而 box-sizing 正是调整内部 width 作用细节而定义的方式，box-sizing:border-box,即为IE盒子的计算方式，将 width 作用在 border-box上面。\n外部尺寸：\n\n\n正常流宽度（表现为“外部尺寸”的块级元素一旦设置了宽度，流动性就丢失了）\n格式化宽度（仅出现在绝对定位模型中，默认情况下，绝对定位的宽度表现是“包裹”性的，然而非替换元素，当top/left或 right/bottom 等对立方位的属性值提示存在时，元素宽度表示为“格式化宽度”，宽度大小相对于最近的具有定位特性的祖先元素计算，具有完全的流体性）\n\n\n内部尺寸与流体特性\n\n\n包裹性（包裹+自适应）。\n首选最小宽度。即便外部设置width:0;内部的图片文字宽度也会有一个最小宽度而不是0;\n最大宽度，等于设置white-psace设置no-wrap后的宽度。\n\n\nbox-sizing 的设计初衷\n\n解决非替换元素的自适应宽度问题\n\n对于非替换元素，display:block会具有流动性，宽度由外部决定。\n非替换元素宽度不受display/外部容器影响，因而通过给替换元素设置display:block是无法实现宽度100%自适应的。因而需要显式指定width\n\n\n因而，在重置代码里加上 input, textarea, img, video, object { box-sizing:border-box; }是合理且必要的有效\n\n\n为何 height:100%无效，而宽度100%\n\n\n当未指定高度值时默认值为auto而单位百分比则是：将高度定义为相对包含块高度的百分比。\n\n1&apos;auto&apos;*100%=NaN\n\n\nwidth 默认虽然也是auto，但是只却是有真实值计算而来的\n\n\n非绝对定位元素的宽高百分比是对应 content box 的，绝对定位元素的则是对应 padding box的；\nmax-系列的初始值为none, min-系列的则为auto,理解此点对于动画过渡方面的区别挺大的。与height\\width等的覆盖规则：\n\n\nmax-width 将会覆盖width,即便是设置了!important的width;\n在冲突时，min-width 将会覆盖 max-width；\n\n\n根据是否具有可替换内容，元素可分为可替换元素和非替换元素。\n\n\n替换元素：通过修改某个属性值所呈现的内容就会被改变的元素。\n\n特性：\n(1)内容元素的外观不受页面的css影响（本质上是web component,内部样式为shadow dom因而不受外界控制）；\n(2)有自己的尺寸，通常默认为300*150;\n(3)所有替换元素都是内联元素，但是默认的display值却是不一样的。(4)替换元素的尺寸规则：css尺寸&gt;html尺寸&gt;固有尺寸（例如img图片自身的大小）&gt;默认尺寸（在没指定内容时）\n一个为首屏图片不影响布局处理的css：img {visibility:hiden}img[src] {visibility:visible}没有src不会产生任何请求\n其他知识点：\n(5)firefox的::before微元素的content值设置会被无视，after则有效；\n(6)p51一个基于伪元素的图片生成技术，技术支持理论：去掉src属性，很多替换元素就变成替换元素\n\n核心代码\n\n12345678910111213141516img::after &#123;    /* 生成alt信息 */    content: attr(alt);    /* 尺寸和定位 */    position: absolute;    bottom: 0;    width: 100%;    background-color: rgba(0, 0, 0, .5);    transform: translateY(100%);    /* 过渡动画效果 */    transition: transform .2s;&#125;img:hover::after &#123;    /* alt 信息展示 */    transform: translateY(0);&#125;\n\n原理：图片未加载时，没有src此时为非替换元素，hover后显示alt提示文本；加载后为替换元素，:after,:before特性失效\n(7)在chrome下，所有元素都支持content属性，而其他浏览器仅在:before等伪元素内有效。利用content属性，可以让普通标签变成替换元素。应用举例：常见网站的标题用h1标签，但通常都使用特殊处理的字体图片而非直接使用字体，为了保证seo的友好，通常会在标签内写上文字内容，然后设置text-indent:-999px;来隐藏文字。利用content的新方法：\n123h1 &#123;    content:url(logo.svg);&#125;\n\n（8）利用content生成文字的坏处：无法被屏幕阅读设备读取，无法被搜索引擎抓取，对可访问性和seo都不太友好。\n\n非替换元素：\n\n\n关于content内容生成技术\n\n\ncontent辅助元素生成：利用其他css代码来生成辅助元素，或实现图形效果，或实现特定布局，会使HTML代码更加干净简洁。\ncontent字符内容生成：应用例子（iconfont），可利用该特性实现ie6-ie9的动态加载动画效果\ncontent图片生成：通过给content赋予url(图片地址)来实现。现实中很少使用该方式，因为这样生成的图片尺寸不好控制\nattr属性值内容生成（使用方式类似函数，指定的属性值名称不要加引号）\ncontent计数器：应用实例（购物车、书籍目录）\n\n\npadding元素，利用其特性可轻易实现 登录注册中间的“管道符”；实例代码：\n\n1234567a = a:before &#123;    content:&quot;&quot;;    font-size:0;    padding:10px 3px 1px;    margin-left:6px;    border-left；1px solid gray; &#125;\n\n\n内联元素设置padding不会加入行盒高度的计算，也就是不影响布局，但是会实际会发生渲染，可利用此特性给一些内联点击元素扩大点击区域；对于内联元素，padding是会断行的，宽高完全受font-size大小控制、\nmargin\\padding百分比值无论是哪个方向的都是基于宽度计算的\n由于button元素的内置padding在多浏览器下很难控制，因而通常都使用a模拟按钮居多。\n可以利用padding来实现三道杠和双层圆点。\n关于内部尺寸与margin\\padding的关系：两者都可以改变元素的可视尺寸，对于padding，元素设置了width或者保持其包裹性时，会改变元素尺寸，而margin,只有在元素是“充分利用可用空间”状态（流布局，宽度自适应），才可以改变元素尺寸。可利用此特性，使用负值margin来消除最后一个子元素margin-left。\n对于普通的块状元素，在默认的水平流下，margin只能改变左右方向的内部尺寸。但如果使用writing-mode改变流向为垂直流，则水平方向内部尺寸无法改变，垂直方向可以改变。\n如果容器可以滚动，在IE和FireBox下是会忽略padding-bottom值的。因而只能使用子元素的margin-bottom来实现滚动容器的底部留白。\n使用margin负值可以实现等高布局，但无法满足子元素需要需要定位在父容器之外的布局。\nmargin合并只发生在：（1）垂直方向；（2）块级元素（不包括浮动和绝对定位元素）\nmargin合并的三种场景：（1）相邻兄弟元素的上下margin；（2）父级和第一个/最后一个子元素。阻止该情况margin合并的方式：对于margin-top的处理方法（满足一个即可）\n\n\n父元素设置为块状格式化上下文元素；\n父元素设置Border-top;\n父元素设置padding-top;\n父元素和第一个子元素之间添加内联元素进行分隔；对于margin-bottom的处理方法（满足一个）\n父元素设置为块状格式化上下文元素；\n父元素设置Border-bottom;\n父元素设置padding-bottom;\n父元素设置height\\min-height\\或max-height；(3)空块级元素的margin合并\n\n28.\n","plink":"https://yanoo1497.github.io/post/css世界/"},{"title":"CSS 优化细则","date":"2017-03-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.371Z","content":"\n慎重使用高性属性：浮动、定位；\n去除空规则；\n属性值为0时，不加单位；\n属性值为浮点数0.**时，可以省略小数点前的0；\n标准化各种浏览器前缀，带浏览器前缀的在前，标准的在后；\n不使用@import前缀，它会影响css加载速度；\n充分利用css继承属性，减少代码量；\n抽象提取公用样式，减少代码量；\n选择器优化嵌套，尽量避免层级过深；\n将css文件放在页面的最上面；\n避免使用复杂的选择器，层级越少越好　　\n\n有时候项目的模块越来越多，功能越来越复杂，我们写的CSS选择器会内套多层，越来越复杂。　　\n建议选择器的嵌套最好不要超过三层，比如：\n1.header .logo .text&#123;&#125;\n\n可以优化成\n1.haeder .logo-text&#123;&#125;\n\n简洁的选择器不仅可以减少css文件大小，提高页面的加载性能，浏览器解析时也会更加高效，也会提高开发人员的开发效率，降低了维护成本。\n5、利用CSS继承减少代码量　　我们知道有一部分CSS代码是可以继承的，如果父元素已经设置了该样式，子元素就不需要去设置该样式，这个也是提高性能的行之有效的方法。　　\n常见的可以继承的属性比如：　　color，font-size，font-family等等　　\n不可继承的比如：　　position，display，float等\n关于CSS方法论\n","plink":"https://yanoo1497.github.io/post/css优化细则/"},{"title":"两数之和","date":"2017-03-16T06:32:22.000Z","updated":"2021-06-12T10:38:30.381Z","content":"题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例:\n1234if nums = [2, 7, 11, 15], target = 9because nums[0] + nums[1] = 2 + 7 = 9so return [0, 1]\n\n结题：\n123456789101112131415var twoSum = function(nums, target) &#123;    let hash = &#123;&#125;;    let temp;    let len = nums.length;    for (let i = 0; i &lt; len; i++) &#123;        hash[nums[i]] = i;    &#125;    for (let j = 0; j &lt; len; j++) &#123;        temp = target - nums[j];        if(hash[temp] &amp;&amp; hash[temp] !== j) &#123;            return [j, hash[temp]];        &#125;    &#125;    console.log(\"Not found.\");&#125;;\n\n","plink":"https://yanoo1497.github.io/post/twosum/"}]