{"title":"《JavaScript 忍者秘籍》读书笔记","date":"2020-04-02T07:20:41.000Z","link":"post/js","tags":["book","javascript"],"updated":"2021-06-12T10:38:29.432Z","content":"<blockquote>\n<p>清明假期两天刷完的一本书，干货挺多的，值得观看。不过比较后面几个Dom、浏览器兼容的章节就没怎么看，重点都在中间的部分，尤其是关于函数、生成器和原型对象部分讲解的比较精彩，配图细致。以下内容是当天看完整理出来的稍微改动的书摘，记录的是我看时比较有收获的点作为记录，推荐大家自行观看原文。<br><a href=\"https://weread.qq.com/web/reader/a9f32eb0715a41a9a9f7812k98f3284021498f137082c2e\" target=\"_blank\" rel=\"noopener\">微信读书原文链接</a></p>\n</blockquote>\n<h2 id=\"页面生命周期\">页面生命周期<a href=\"post/js#页面生命周期\"></a></h2><p><a href=\"http://note.youdao.com/noteshare?id=be872083944d5a98104203ce0139075d\" target=\"_blank\" rel=\"noopener\">思维导图</a>：<br><img src=\"https://user-images.githubusercontent.com/27424848/78416771-e852d480-765d-11ea-8ce3-03f64482ee82.png\" alt=\"image\"></p>\n<p><strong>客户端Web应用的执行分为两个阶段</strong></p>\n<ul>\n<li><p>页面构建阶段：页面构建代码是用于创建DOM的，而全局JavaScript代码是遇到script节点时执行的。在这个执行过程中，JavaScript代码能够以任意程度改变当前的DOM，并且注册事件处理器。</p>\n</li>\n<li><p>事件处理——<strong>在同一时刻，只能处理多个不同事件中的一个，处理顺序是事件生成的顺序</strong>。事件处理阶段大量依赖事件队列，所有的事件都以其出现的顺序存储在事件队列中。事件循环会检查实践队列的队头，如果检测到了一个事件，那么相应的事件处理器就会被调用。</p>\n</li>\n</ul>\n<h2 id=\"关于函数\">关于函数<a href=\"post/js#关于函数\"></a></h2><p>需要有的一个认知：<strong>函数是一等公民（一级对象）</strong>，JS 是函数式编程的语言。</p>\n<h3 id=\"匿名立即执行函数\">匿名立即执行函数<a href=\"post/js#匿名立即执行函数\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;)()</span><br></pre></td></tr></table></div></figure>\n\n<h4 id=\"为什么匿名自执行函数需要-（）-包裹\">为什么匿名自执行函数需要 （） 包裹<a href=\"post/js#为什么匿名自执行函数需要-（）-包裹\"></a></h4><p>函数表达式被包裹在一对括号内其原因是纯语法层面的。</p>\n<p>JavaScript解析器必须能够轻易区分函数声明和函数表达式之间的区别。如果去掉包裹函数表达式的括号，把立即调用作为一个独立语句function() {}(3), JavaScript开始解析时便会结束，因为这个独立语句以function开头，那么解析器就会认为它在处理一个函数声明。每个函数声明必须有一个名字（然而这里并没有指定名字），所以程序执行到这里会报错。<strong>为了避免错误，函数表达式要放在括号内，为JavaScript解析器指明它正在处理一个函数表达式而不是语句</strong>。</p>\n<p>还有一种相对简单的替代方案 (function(){}(3)) 也能达到相同目标（然而这种方案有些奇怪，故不常使用）。把立即函数的定义和调用都放在括号内，同样可以为JavaScript解析器指明它正在处理函数表达式。在JavaScript库中会经常见到这几种形式：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;()</span><br><span class=\"line\">-<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;()</span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;()</span><br><span class=\"line\">~<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;()</span><br></pre></td></tr></table></div></figure>\n\n<p>不同于用加括号的方式区分函数表达式和函数声明，这里我们使用一元操作符+、-、！和~。这种做法也是用于向JavaScript引擎指明它处理的是表达式，而不是语句。</p>\n<h3 id=\"函数参数-arguments\">函数参数 arguments<a href=\"post/js#函数参数-arguments\"></a></h3><h4 id=\"定义\">定义<a href=\"post/js#定义\"></a></h4><p>arguments 参数是传递给函数的所有参数集合。无论是否有明确定义对应的形参，通过它我们都可以访问到函数的所有参数。借此可以实现原生 JavaScript 并不支持的函数重载特性，而且可以实现接收参数数量可变的可变函数。</p>\n<p><strong>注意</strong>：arguments 对象仅是一个<strong>类数组</strong>的结构，避免把arguments 参数当作_数组_。你可能会被它的用法误导，毕竟它有 length 属性，而且可以通过数组下标的方式访问到每一个元素。但它并非 JavaScript 数组，如果你尝试在 <code>arguments</code> 对象上使用数组的方法（例如sort方法），会发现最终会报错。</p>\n<p>在大多数情况下<strong>可以使用剩余参数（rest parameter）来代替arguments 参数。剩余参数是真正的 Array 实例</strong>，可以在它上面直接使用所有的数组方法。</p>\n<h4 id=\"arguments-与形参变量是相关联的\">arguments 与形参变量是相关联的<a href=\"post/js#arguments-与形参变量是相关联的\"></a></h4><p>在非严格模式下，<strong><code>arguments</code> 对象是函数参数的别名，修改 <code>arguments</code> 对象会修改函数实参</strong>，可以通过严格模式避免修改函数实参。</p>\n<h3 id=\"函数的调用\">函数的调用<a href=\"post/js#函数的调用\"></a></h3><h4 id=\"1-作为函数直接被调用\">1. 作为函数直接被调用<a href=\"post/js#1-作为函数直接被调用\"></a></h4><p>当以这种方式调用时，函数上下文（<code>this</code> 关键字的值）有两种可能性：在非严格模式下，它将是全局上下文（<code>window</code> 对象），而在严格模式下，它将是 <code>undefined</code>。</p>\n<h4 id=\"2-作为对象的方法被调用\">2. 作为对象的方法被调用<a href=\"post/js#2-作为对象的方法被调用\"></a></h4><p>当函数作为某个对象的方法被调用时，该对象会成为函数的上下文，并且在函数内部可以通过参数 <code>this</code> 访问到调用对象。</p>\n<h4 id=\"3-作为构造函数使用-new-关键字调用\">3. 作为构造函数使用 new 关键字调用<a href=\"post/js#3-作为构造函数使用-new-关键字调用\"></a></h4><p>使用关键字 <code>new</code> 调用函数会触发以下几个动作。</p>\n<ul>\n<li>1．创建一个新的空对象。</li>\n<li>2．该对象作为 <code>this</code> 参数传递给构造函数，从而成为构造函数的函数上下文。</li>\n<li>3．新构造的对象作为 <code>new</code> 运算符的返回值</li>\n</ul>\n<p>构造函数的目的是创建一个新对象，并进行初始化设置，然后将其作为构造函数的返回值。任何有悖于这两点的情况都不适合作为构造函数。</p>\n<blockquote>\n<p><strong>注意</strong>：<strong>如果构造函数返回一个对象，则该对象将作为整个表达式的值返回，而传入构造函数的 <code>this</code> 将被丢弃</strong>。但是，如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象。</p>\n</blockquote>\n<p>构造函数的目的是根据初始条件对函数调用创建的新对象进行初始化。</p>\n<h4 id=\"不同调用方式的区别\">不同调用方式的区别<a href=\"post/js#不同调用方式的区别\"></a></h4><p>不同类型函数调用之间的主要区别在于：最终作为<strong>函数上下文</strong>（可以通过 <code>this</code> 参数隐式引用到）传递给执行函数的对象不同。</p>\n<h3 id=\"修改函数上下文对象的方式\">修改函数上下文对象的方式<a href=\"post/js#修改函数上下文对象的方式\"></a></h3><h4 id=\"使用现成方法\">使用现成方法<a href=\"post/js#使用现成方法\"></a></h4><p><code>apply,call,bind</code></p>\n<p><code>apply</code> 和 <code>call</code> 之间唯一的不同之处在于如何传递参数。在使用 <code>apply</code>的情况下，我们使用参数数组；在使用 <code>call</code> 的情况下，我们则在函数上下文之后依次列出调用参数。</p>\n<p>所有函数均可访问 <code>bind</code> 方法，可以创建并返回一个<strong>新函数</strong>，并绑定在传入的对象上。</p>\n<blockquote>\n<p><strong>注意</strong>：如果在事件绑定时使用了 bind 过的函数，解绑时不能使用原函数解绑。</p>\n</blockquote>\n<h4 id=\"使用箭头函数\">使用箭头函数<a href=\"post/js#使用箭头函数\"></a></h4><p>箭头函数没有单独的 <code>this</code> 值，<code>this</code> 在箭头函数创建时确定。</p>\n<h3 id=\"闭包和作用域\">闭包和作用域<a href=\"post/js#闭包和作用域\"></a></h3><p>闭包是纯函数式编程语言的特性之一</p>\n<p>JS 的代码有两种类型：</p>\n<ol>\n<li>全局代码，在所有函数外部定义。</li>\n<li>函数代码，位于函数内部。</li>\n</ol>\n<p>JavaScript引擎执行代码时，每一条语句都处于特定的执行上下文中。既然具有两种类型的代码，那么就有两种执行上下文：全局执行上下文和函数执行上下文。</p>\n<p>二者最重要的差别是：<strong>全局执行上下文只有一个，当 JavaScript 程序开始执行时就已经创建了全局上下文；而函数执行上下文是在每次调用函数时，就会创建一个新的</strong>。</p>\n<p>JS 在某个特定的时刻只能执行特定的代码。一旦发生函数调用，当前的执行上下文必须停止执行，并创建新的函数执行上下文来执行函数。当函数执行完成后，将函数执行上下文销毁，并重新回到发生调用时的执行上下文中。所以需要跟踪执行上下文——正在执行的上下文以及正在等待的上下文。最简单的跟踪方法是使用执行上下文栈（或称为调用栈）</p>\n<p>词法环境是 JavaScript 作用域的内部实现机制，人们通常称为作用域(scopes)。</p>\n<p>var 声明的变量实际上总是在距离最近的函数内或全局词法环境中注册的，不关注块级作用域。</p>\n<p>var 是在距离最近的函数或全局词法环境中定义变量，与var不同的是，let 和 const 更加直接。let 和 const 直接在最近的词法环境中定义变量（可以是在块级作用域内、循环内、函数内或全局环境内）。我们可以使用 let 和 const 定义块级别、函数级别、全局级别的变量。</p>\n<h3 id=\"生成器和-promise\">生成器和 promise<a href=\"post/js#生成器和-promise\"></a></h3><h4 id=\"生成器内部实现\">生成器内部实现<a href=\"post/js#生成器内部实现\"></a></h4><p>通过调用生成器得到的迭代器，暴露出一个 <code>next</code> 方法能让我们向迭代器请求一个新值。<code>next</code> 方法返回一个携带着生成值的对象，而该对象中包含的另一个属性<code>done</code>也向我们指示了生成器是否还会追加生成值。在生成器生成（或让渡）了一个值后，生成器会挂起执行并等待下一个请求的到来。在某种方面来说，生成器的工作更像是一个小程序，一个在状态中运动的状态机。</p>\n<ul>\n<li>挂起开始 —— 创建了一个生成器后，它最先以这种状态开始。其中的任何代码都未执行。</li>\n<li>执行 —— 生成器中的代码已执行。执行要么是刚开始，要么是从上次挂起的时候继续的。当生成器对应的迭代器调用了 <code>next</code> 方法，并且当前存在可执行的代码时，生成器都会转移到这个状态。</li>\n<li>挂起让渡 —— 当生成器在执行过程中遇到了一个 <code>yield</code> 表达式，它会创建一个包含着返回值的新对象，随后再挂起执行。生成器在这个状态暂停并等待继续执行。</li>\n<li>完成 —— 在生成器执行期间，如果代码执行到 <code>return</code> 语句或者全部代码执行完毕，生成器就进入该状态。</li>\n</ul>\n<p>在迭代器上使用 <code>yield*</code> 操作符，程序会跳转到另外一个生成器上执行。</p>\n<h4 id=\"使用迭代器生成-ID-序列\">使用迭代器生成 ID 序列<a href=\"post/js#使用迭代器生成-ID-序列\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> IDGenerator = (<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> id = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> ++id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"keyword\">const</span> id_1 = IDGenerator.next(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> id_2 = IDGenerator.next(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></div></figure>\n\n<p>优点：使用方式简单，id 值在闭包里面不容易被外部修改到</p>\n<h4 id=\"async-函数\">async 函数<a href=\"post/js#async-函数\"></a></h4><h4 id=\"函数和生成器的差异\">函数和生成器的差异<a href=\"post/js#函数和生成器的差异\"></a></h4><p>函数和生成器之间的关键不同在于，<strong>标准函数仅仅会被重复调用，每次调用都会创建一个新的执行环境上下文</strong>。相比之下，生成器的执行环境上下文则会暂时挂起并在将来恢复。</p>\n<h2 id=\"对象与原型\">对象与原型<a href=\"post/js#对象与原型\"></a></h2><p>关于原型的其他内容，可以参考之前的：<br><a href=\"https://yanoo1497.github.io/post/prototype\">JS 原型链速记总结</a></p>\n<p>在 JavaScript 中，对象的原型属性是内置属性（使用标记<code>[[prototype]]</code>），无法直接访问。可以使用内置的方法 <code>Object.setPrototypeOf</code> 需要传入两个对象作为参数，并将第二个对象设置为第一个对象的原型。</p>\n<h3 id=\"利用闭包创建对象私有变量\">利用闭包创建对象私有变量<a href=\"post/js#利用闭包创建对象私有变量\"></a></h3><p>在构造函数内部定义方法，使得我们可以模仿私有对象变量。如果我们需要私有对象，在构造函数内指定方法是唯一的解决方案。</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.test = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'this test'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.test = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'prototype test'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person.test(); <span class=\"comment\">// this test</span></span><br></pre></td></tr></table></div></figure>\n\n<p>在构造函数内部，关键字 <code>this</code> 指向新创建的对象，所以在构造器内添加的属性直接在新的实例上，person 实例在调用 test 方法时不需要查找原型链，因而输出的时 this 上绑定方法的结果。</p>\n<p>因而一些公用方法的定义并不推荐直接绑定在 <code>this</code> 上，会使每个实例对象都挂上一个相同的方法，更好的方式是将其绑定在构造函数的 <code>prototype</code> 上，充分利用 js 的继承。但是这个特性也可以利用来生成私有方法。</p>\n<h3 id=\"利用-constructor-引用创建新对象\">利用 constructor 引用创建新对象<a href=\"post/js#利用-constructor-引用创建新对象\"></a></h3><p>我们可以使用 <code>constructor</code> 属性验证实例的原始类型（与操作符<code>instanceof</code> 非常类似）</p>\n<p>由于 <code>constructor</code> 属性仅仅是原始构造函数的引用，因此我们可以使用该属性创建新的实例对象，例如：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"keyword\">new</span> interface.constructor();</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"利用原型实现继承\">利用原型实现继承<a href=\"post/js#利用原型实现继承\"></a></h3><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Ninjia</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 所有继承函数的原型将实时更新</span></span><br><span class=\"line\"><span class=\"comment\">// Ninja.prototype = Person.prototype;</span></span><br><span class=\"line\"><span class=\"comment\">// const ninja = new Ninja();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. </span></span><br><span class=\"line\"><span class=\"comment\">// Ninja.prototype = new Person();</span></span><br><span class=\"line\"><span class=\"comment\">// const ninjia = new Ninjia();</span></span><br></pre></td></tr></table></div></figure>\n\n<ol>\n<li><p>直接使用 Person 的原型对象作为 Ninja 的原型，如 <code>Ninja.prototype = Person.prototype</code>。这样做会导致在 Person 原型上所发生的所有变化都被同步到 Ninja 原型上（Person 原型与 Ninja 原型是同一个对象），一定会有不良的副作用。这种原型实现继承的方式的副作用好的一面是，所有继承函数的原型将实时更新。从原型继承的对象总是可以访问当前原型属性。</p>\n</li>\n<li><p>将 Person 的实例对象作为 Ninja 的原型</p>\n</li>\n</ol>\n<p><strong>带来的问题</strong>：</p>\n<p>通过设置 Person 实例对象作为 Ninja 构造器的原型时，我们已经丢失了 Ninja 与 Ninja 初始原型之间的关联，无法再通过 <code>constructor</code> 获取 Ninja 的引用。如果其他地方使用了 constructor 属性检测一个对象是否由某一个函数创建，就会产生错误。</p>\n<p><strong>解决方式</strong>：</p>\n<p>使用 <code>Object.defineProperty</code> 方法在 Ninja.prototype 对象上增加新的 <code>constructor</code> 属性。</p>\n<p><img src=\"https://user-images.githubusercontent.com/27424848/78471979-ed03af80-7767-11ea-9f59-23c0a952444a.png\" alt=\"image\" class=\"article-img\"></p>\n<h4 id=\"Es6-class\">Es6 class<a href=\"post/js#Es6-class\"></a></h4><p>由于每个类库对类的实现都有不同的方式，ECMAScript委员会对“模拟”基于类的继承语法进行标准化。注意是“模拟”。虽然现在我们可以在JavaScript中使用关键字class，但其<strong>底层的实现仍然是基于原型继承！class只是语法糖</strong>，使得在JavaScript模拟类的代码更为简洁罢了。</p>\n<p><strong>关于静态属性方法</strong>：</p>\n<p>我们只需要记住通过函数来实现类。由于静态方法是类级别的方法，所以可以利用第一类型对象，在构造函数上添加方法</p>\n<h4 id=\"关于-instanceof\">关于 instanceof<a href=\"post/js#关于-instanceof\"></a></h4><p>定义：<strong>检查右边的函数原型是否存在于操作符左边的对象的原型链上</strong></p>\n<p>在JavaScript中，操作符 <code>instanceof</code> 将会查找整个原型链，尽管经常用来确定一个实例是否是由一个特定的构造函数创建的，但是并不完全准确。</p>\n<h3 id=\"控制对象的访问\">控制对象的访问<a href=\"post/js#控制对象的访问\"></a></h3><h4 id=\"定义-getter-和-setter\">定义 getter 和 setter<a href=\"post/js#定义-getter-和-setter\"></a></h4><ul>\n<li>通过对象字面量定义，或在ES6的class中定义。</li>\n<li>通过使用内置的Object.defineProperty方法。</li>\n</ul>\n<h4 id=\"通过-代理（proxy）\">通过 代理（proxy）<a href=\"post/js#通过-代理（proxy）\"></a></h4><p>代理（proxy）是我们通过代理控制对另一个对象的访问。通过代理可以定义当对象发生交互时可执行的自定义行为——如读取或设置属性值，或调用方法。可以将代理理解为通用化的setter与getter，区别是每个setter与getter仅能控制单个对象属性，而代理可用于对象交互的通用处理，包括调用对象的方法。过去使用setter与getter处理日志记录、数据校验、计算属性等操作，均可使用代理对它们进行处理。</p>\n<p><strong>实际应用</strong></p>\n<ol>\n<li>JavaScript不支持数组负索引，但是，我们可以使用代理进行模拟</li>\n<li>属性修改检验，默认值写入</li>\n</ol>\n<p>尽管使用代理可以创造性地控制对象的访问，但是大量的控制操作将带来性能问题。可以在多性能不敏感的程序里使用代理，但是若多次执行代码时仍然要小心谨慎。像往常一样，我们建议你彻底地测试代码的性能。</p>\n<h2 id=\"集合\">集合<a href=\"post/js#集合\"></a></h2><p>原型继承属性以及key仅支持字符串，所以通常不能使用对象作为map。由于这种限制，ECMAScript委员会定义了一个全新类型：Map。</p>\n<p>因为map是集合，<strong>可以使用for of循环遍历 map,并且可以确保遍历的顺序与插入的顺序一致</strong>。</p>\n<h2 id=\"正则表达式\">正则表达式<a href=\"post/js#正则表达式\"></a></h2><p>当正则表达式在开发环境是明确的，推荐<strong>优先使用字面量语法</strong>；当需要在运行时动态创建字符串来构建正则表达式时，则使用构造函数的方式。优先使用字面量语法，原因之一是反斜线在正则表达式中发挥了重要的作用。但是反斜线也用于转义字符，因此，对于反斜线本身则需要使用双反斜线来标识\\。这使得本来就很奇怪的正则表达式表示字符串时看起来更加诡异。</p>\n<p>反向引用可引用正则中定义的捕获</p>\n<h3 id=\"处理正则的基础流程\">处理正则的基础流程<a href=\"post/js#处理正则的基础流程\"></a></h3><p>处理正则表达式经历多个阶段，理解每个阶段的处理有助于使用正则表达式优化JavaScript代码。其中两个主要的阶段是编译和执行。编译阶段发生在正则表达式被创建的时期。执行阶段发生在使用编译之后的正则表达式进行匹配字符串的时期。</p>\n<h4 id=\"编译\">编译<a href=\"post/js#编译\"></a></h4><p>每个正则表达式都有一个独特的对象表示：每次创建一个正则表达式（也被编译）都会<strong>创建一个新的正则表达式对象</strong>。这与原始类型（如string、number等）不同，因为每个正则对象永远是独一无二的。</p>\n<p><strong>一些使用 Tips</strong></p>\n<ul>\n<li><p>推荐使用预创建和预编译的正则表达式，以便以后重复使用，这对性能的提升不容忽视。几乎所有复杂的正则表达式都能从中受益。</p>\n</li>\n<li><p>可以在全局匹配中使用正则表达式的exec方法，每次调用都可以返回下一个匹配的结果，这样可以使用缓存来访问到所有匹配对象。</p>\n</li>\n<li><p>圆括号有两项职责：不仅定义分组，而且还可以指定捕获。说明有一组括号不应该产生捕获，正则表达式语法可以在起始圆括号之后使用符号<code>？:</code>。这就是所谓的被动子表达式（passive subexpression）</p>\n<p>  <strong>注意</strong>：尽可能在我们的正则表达式中，在不需要捕获的情况下，使用非捕获分组代替捕获，表达式引擎不需要记忆和返回捕获结果，这可以减少很多工作。</p>\n</li>\n</ul>\n<p><strong>其他</strong></p>\n<p>replace 最重要的特性是不仅支持替换值，而且支持替换函数作为参数。当第2个参数是函数时，对每一个所匹配到的值都会调用一遍（全局匹配会返回匹配到的全部内容）</p>\n<h2 id=\"代码模块化\">代码模块化<a href=\"post/js#代码模块化\"></a></h2><p>小的、组织良好的代码远比庞大的代码更容易理解、更易于维护。因此，很自然，优化程序的结构和组织的方式，就是把它们分成小的、耦合相对松散的片段，这些片段称为模块。</p>\n<p>模块是比对象和函数更大的代码单元，使用模块可以将程序进行归类。创建模块时，我们应该努力形成一致的抽象和封装。这样有益于思考应用程序，当使用模块的功能时，可以避免被琐碎细节干扰。</p>\n<p>JavaScript ES6 之前，只有两种作用域：全局作用域和函数作用域。没有介于两者之间的作用域，没有命名空间或模块可以将功能进行分组。为了编写模块化代码，JavaScript开发者们不得不创造性地使用JavaScript现有的语法特性。</p>\n<p>当决定使用哪种模块系统时，我们需要谨记，每个模块系统至少应该能够执行以下操作：</p>\n<ul>\n<li>定义模块接口，通过接口可以调用模块的功能。</li>\n<li>隐藏模块的内部实现，使模块的使用者无需关注模块内部的实现细节。同时，隐藏模块的内部实现，避免有可能产生的副作用和对bug的不必要修改。</li>\n</ul>\n<h3 id=\"AMD-和-CommonJS\">AMD 和 CommonJS<a href=\"post/js#AMD-和-CommonJS\"></a></h3><p>AMD 和 CommonJS 是两个相互竞争的标准，均可以定义JavaScript模块。除了语法和原理的区别之外，主要的区别是AMD的设计理念是明确基于浏览器，而CommonJS的设计是面向通用JavaScript环境（如Node.js服务端），而不局限于浏览器。</p>\n<h4 id=\"AMD-优点\">AMD 优点<a href=\"post/js#AMD-优点\"></a></h4><ul>\n<li>自动处理依赖，我们无需考虑模块引入的顺序。</li>\n<li>异步加载模块，避免阻塞。</li>\n<li>在同一个文件中可以定义多个模块。</li>\n</ul>\n<p>文件同步加载，可以访问模块公共接口。这是CommonJS在服务端更流行的原因，模块加载相对更快，只需要读取文件系统，而在客户端则必须从远程服务器下载文件，同步加载通常意味着阻塞。</p>\n<h3 id=\"CommonJS-优势\">CommonJS 优势<a href=\"post/js#CommonJS-优势\"></a></h3><ul>\n<li>语法简单。只需定义module.exports属性，剩下的模块代码与标准JavaScript无差异。引用模块的方法也很简单，只需要使用require函数。</li>\n<li>CommonJS 是 Node.js 默认的模块格式，所以我们可以使用npm上成千上万的包。</li>\n</ul>\n<h3 id=\"Es6-模块\">Es6 模块<a href=\"post/js#Es6-模块\"></a></h3><p>集合两大模块系统优点</p>\n<ul>\n<li>与CommonJS类似，ES6模块语法相对简单，并且基于文件（每个文件就是一个模块）。</li>\n<li>与AMD类似，ES6模块支持异步模块加载。</li>\n</ul>\n<p>ES6模块的主要思想是必须显式地使用标识符导出模块，才能从外部访问模块。其他标识符，甚至在最顶级作用域中定义的（可能是标准JavaScript中的全局作用域）标识符，只能在模块内使用。这一点是受到CommonJS启发。为了提供这个功能，ES6引入两个关键字。<br>● export——从模块外部指定标识符。<br>● import——导入模块标识符。</p>\n<p>需要时，可以使用 as 关键字同时重命名export和import。</p>\n<h2 id=\"JS-的-DOM-操作\">JS 的 DOM 操作<a href=\"post/js#JS-的-DOM-操作\"></a></h2><ul>\n<li><p>元素的style属性中的任何值，都优先于样式表继承的值（即使样式表规则使用！important的注释）</p>\n</li>\n<li><p>多个单词的CSS样式名称作为属性名时，会转换为驼峰格式</p>\n</li>\n<li><p>一个元素的计算后样式（computed style）都是应用在该元素上的所有样式的组合，这些样式包括样式表、元素的style特性，以及脚本对style做的各种操作。</p>\n</li>\n<li><p>与元素样式对象不同，getPropertyValue方法接收CSS属性名称（例如font-size和background-color），而不是这些名称的驼峰式版本</p>\n</li>\n<li><p>并非所有的数值都代表像素,有很多style的属性值表示的不是像素尺寸。<code>z-index, font-weight, opacity, zoom, line-height</code>对于这些（以及其他我们所能想到的）属性&gt;同样，在尝试获取style特性的像素值时，应该使用 parseFloat 方法进行转换操作，以确保在任何情况下获取的值都是预期值。</p>\n</li>\n<li><p>offsetHeight 和 offsetWidth都提供了这样的功能：可以相当可靠地访问实际元素的高度和宽度。但是请注意，这两个属性的值都包含了元素的padding值。</p>\n</li>\n<li><p>避免布局抖动的一种方法，就是使用不会导致浏览器重排的方式编写代码</p>\n</li>\n</ul>\n<h2 id=\"事件\">事件<a href=\"post/js#事件\"></a></h2><p>事件循环不仅仅包含事件队列，而是具有至少两个队列，除了事件，还要保持浏览器执行的其他操作。这些操作被称为任务，并且分为两类：宏任务（或通常称为任务）和微任务。</p>\n<h3 id=\"宏任务\">宏任务<a href=\"post/js#宏任务\"></a></h3><p>宏任务的例子很多，包括创建主文档对象、解析HTML、执行主线（或全局）JavaScript代码，更改当前URL以及各种事件，如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，宏任务代表一个个离散的、独立工作单元。运行完任务后，浏览器可以继续其他调度，如重新渲染页面的UI或执行垃圾回收。</p>\n<h3 id=\"微任务\">微任务<a href=\"post/js#微任务\"></a></h3><p>而微任务是更小的任务。微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。微任务的案例包括promise回调函数、DOM发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使应用程序的状态不连续。</p>\n<p>事件循环的实现至少应该含有一个用于宏任务的队列和至少一个用于微任务的队列。大部分的实现通常会更多用于不同类型的宏任务和微任务的队列。这使得事件循环能够根据任务类型进行优先处理。例如，优先考虑对性能敏感的任务，如用户输入。另一方面，由于在市面上的浏览器和JavaScript执行环境多如牛毛，所以如果发现所有任务都在一个队列的事件循环，也不要过分惊讶。</p>\n<p>事件循环基于两个基本原则：</p>\n<ul>\n<li>一次处理一个任务</li>\n<li>一个任务开始后直到运行完成，不会被其他任务中断</li>\n</ul>\n<p><strong>注意处理宏任务和微任务队列之间的区别</strong>：<br>单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理。</p>\n<p>每当执行一个任务时，事件循环总是首先检查微任务队列，目的是在处理其他任务之前把所有的微任务执行完毕。</p>\n<p>在两个宏任务之间，可以重新渲染页面（主线程和第一个按钮单击任务之间），而在微任务执行之前不允许重新渲染页面</p>\n<p>事件处理器的优点之一是，我们可以创建任意数量的事件处理器，并且事件处理器之间是完全独立的。</p>\n","prev":{"title":"编写一个函数计算多个数组的交集","link":"post/intersect"},"next":{"title":"Git 常用操作以及相关文章记录（自检清单）","link":"post/git"},"plink":"https://yanoo1497.github.io/post/js/","toc":[{"title":"页面生命周期","id":"页面生命周期","index":"1"},{"title":"关于函数","id":"关于函数","index":"2","children":[{"title":"匿名立即执行函数","id":"匿名立即执行函数","index":"2.1","children":[{"title":"为什么匿名自执行函数需要 （） 包裹","id":"为什么匿名自执行函数需要-（）-包裹","index":"2.1.1"}]},{"title":"函数参数 arguments","id":"函数参数-arguments","index":"2.2","children":[{"title":"定义","id":"定义","index":"2.2.1"},{"title":"arguments 与形参变量是相关联的","id":"arguments-与形参变量是相关联的","index":"2.2.2"}]},{"title":"函数的调用","id":"函数的调用","index":"2.3","children":[{"title":"1. 作为函数直接被调用","id":"1-作为函数直接被调用","index":"2.3.1"},{"title":"2. 作为对象的方法被调用","id":"2-作为对象的方法被调用","index":"2.3.2"},{"title":"3. 作为构造函数使用 new 关键字调用","id":"3-作为构造函数使用-new-关键字调用","index":"2.3.3"},{"title":"不同调用方式的区别","id":"不同调用方式的区别","index":"2.3.4"}]},{"title":"修改函数上下文对象的方式","id":"修改函数上下文对象的方式","index":"2.4","children":[{"title":"使用现成方法","id":"使用现成方法","index":"2.4.1"},{"title":"使用箭头函数","id":"使用箭头函数","index":"2.4.2"}]},{"title":"闭包和作用域","id":"闭包和作用域","index":"2.5"},{"title":"生成器和 promise","id":"生成器和-promise","index":"2.6","children":[{"title":"生成器内部实现","id":"生成器内部实现","index":"2.6.1"},{"title":"使用迭代器生成 ID 序列","id":"使用迭代器生成-ID-序列","index":"2.6.2"},{"title":"函数和生成器的差异","id":"函数和生成器的差异","index":"2.6.3"}]}]},{"title":"对象与原型","id":"对象与原型","index":"3","children":[{"title":"利用闭包创建对象私有变量","id":"利用闭包创建对象私有变量","index":"3.1"},{"title":"利用 constructor 引用创建新对象","id":"利用-constructor-引用创建新对象","index":"3.2"},{"title":"利用原型实现继承","id":"利用原型实现继承","index":"3.3","children":[{"title":"Es6 class","id":"Es6-class","index":"3.3.1"},{"title":"关于 instanceof","id":"关于-instanceof","index":"3.3.2"}]},{"title":"控制对象的访问","id":"控制对象的访问","index":"3.4","children":[{"title":"定义 getter 和 setter","id":"定义-getter-和-setter","index":"3.4.1"},{"title":"通过 代理（proxy）","id":"通过-代理（proxy）","index":"3.4.2"}]}]},{"title":"集合","id":"集合","index":"4"},{"title":"正则表达式","id":"正则表达式","index":"5","children":[{"title":"处理正则的基础流程","id":"处理正则的基础流程","index":"5.1","children":[{"title":"编译","id":"编译","index":"5.1.1"}]}]},{"title":"代码模块化","id":"代码模块化","index":"6","children":[{"title":"AMD 和 CommonJS","id":"AMD-和-CommonJS","index":"6.1","children":[{"title":"AMD 优点","id":"AMD-优点","index":"6.1.1"}]},{"title":"CommonJS 优势","id":"CommonJS-优势","index":"6.2"},{"title":"Es6 模块","id":"Es6-模块","index":"6.3"}]},{"title":"JS 的 DOM 操作","id":"JS-的-DOM-操作","index":"7"},{"title":"事件","id":"事件","index":"8","children":[{"title":"宏任务","id":"宏任务","index":"8.1"},{"title":"微任务","id":"微任务","index":"8.2"}]}]}