{"title":"JS 执行字符串代码片段方案","date":"2021-10-10T01:20:41.000Z","link":"post/eval-string","tags":["js"],"updated":"2021-10-10T15:48:40.570Z","content":"<p>在实际项目中，经常会有需要执行某段动态生成代码表达式的需求。本质上就是动态执行某段 js 代码脚本字符串，当然更多时候只是一个代码表达式。</p>\n<h2 id=\"现存的几种方案\">现存的几种方案<a href=\"post/eval-string#现存的几种方案\"></a></h2><h3 id=\"new-Function\">new Function<a href=\"post/eval-string#new-Function\"></a></h3><p><code>new Function()</code> 是 JS 自带的创建函数方法，可以接 n 个参数，最后一个参数作为函数体，通过这种方式可以动态创建一个由某个字符串生成的函数。</p>\n<figure class=\"highlight ts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// const func = new Function([arg1[, arg2[, ...argN]],] functionBody);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> funcA = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'options'</span>, <span class=\"string\">'console.log(options);'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 接收的参数名称需要显式的在定义时指定，functionBody 需要是一段合理的可被执行的代码段，不合法代码段会直接抛出异常</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面这段代码和下面这段是等价的：</p>\n<figure class=\"highlight ts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> funcA = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这意味着，我们将能够从将任意字符串变为函数。例如，我们可以从服务器接收一个新的函数并执行它，或者是支持用户输入一些简单的代码表达式，不过字符串本身由用户输入，为了保证安全性，我们可以利用 with 来做一些变量访问的限制。</p>\n<figure class=\"highlight ts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'console.log(options);'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 'with'语句将某个对象添加到作用域链的顶部，如果某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值，可以减少不必要的指针路径解析运算。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> options = &#123; a: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> funcA = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'options'</span>, <span class=\"string\">`width(options)&#123; <span class=\"subst\">$&#123;str&#125;</span> &#125;`</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>虽然 <code>with</code> 本身并不被 JS 官方推荐，但主要是在日常代码的编写，在这里它恰恰可以起到一写限制变量访问范围的作用。<code>Vue</code> 的模板解析，也是基于这种方式，做到在模板内可以不使用 <code>this</code> 就直接使用里面变量。</p>\n<figure class=\"highlight ts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// template模板</span></span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"app\"</span> style=<span class=\"string\">\"color: red;background: blue;\"</span>&gt;&lt;p&gt;hello &#123;&#123;name&#125;&#125;&lt;<span class=\"regexp\">/p&gt;&#123;&#123;msg&#125;&#125;&lt;/</span>div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解析模板生成一段字符串,即渲染函数要执行的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> code = _c(<span class=\"string\">\"div\"</span>, &#123;id: <span class=\"string\">\"app\"</span>,style: &#123;<span class=\"string\">\"color\"</span>:<span class=\"string\">\" red\"</span>,<span class=\"string\">\"background\"</span>:<span class=\"string\">\" blue\"</span>&#125;&#125;,_c(<span class=\"string\">\"p\"</span>, <span class=\"literal\">undefined</span>,_v(<span class=\"string\">\"hello\"</span>+_s(name))),_v(_s(msg)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将渲染函数要执行的字符串传入new Function()生成渲染函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> renderFn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">`with(this) &#123;return <span class=\"subst\">$&#123;code&#125;</span>&#125;`</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>不过需要注意的是 <strong>如果我们使用 new Function 创建一个函数，那么该函数的作用域并不指向当前的词法环境，而是指向全局环境</strong>，这种和直接在某个位置创建函数不同。所以如果有需要访问局部变量，不能直接利用原来闭包的方式。而需要显式的将参数变量，在创建函数时声明好，使用时传入对应参数。</p>\n<p>这个限制其实本身也有存在的必要，变量名本身在不同的生产环境确实是可能发生变化的，当我们混淆了代码后，原来在某个词法环境内的变量名可能就发生了更改。只有在声明时定义的参数名，才能保证它的稳定性。</p>\n<h3 id=\"eval\">eval<a href=\"post/eval-string#eval\"></a></h3><p>eval 作为一个方法，直接传入要解析的字符串即可，方式简单，并且可以访问到局部变量。</p>\n<figure class=\"highlight ts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">'console.log(options);'</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p>但也正因为毫无限制，存在着许多隐患。<code>eval()</code> 使用与调用者相同的权限执行代码，比如说可能被恶意注入代码，并且使用的性能也不好，由于是支持任意代码，通常比其他替代方法更慢，因为它必须调用 JS 解释器分析词法。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval\" target=\"_blank\" rel=\"noopener\">MDN</a> 上对应文档上已经说明了推荐使用 <code>Function</code> 构造函数来替代这种方式。</p>\n<h3 id=\"通过-node-的核心模块-vm-来实现\">通过 node 的核心模块 vm 来实现<a href=\"post/eval-string#通过-node-的核心模块-vm-来实现\"></a></h3><p>vm 可以使用 v8 的 <code>Virtual Machine contexts</code> 动态地编译和执行代码，而代码的执行上下文是与当前进程隔离的，但是这里的隔离并不是绝对的安全，不完全等同浏览器的沙箱环境。相比前两种方法，这种消耗更高，更适合用于执行比较大的代码段，在一些比较复杂的上下文定义时可以使用。</p>\n<ol>\n<li>vm.runInContext(code, contextifiedObject[, options])</li>\n</ol>\n<p>在指定的 <code>contextifiedObject</code> 的上下文里执行它并返回其结果。 被执行的代码无法获取本地作用域。 <code>contextifiedObject</code> 必须是事先被 <code>vm.createContext()</code> 方法上下文隔离化过的对象。</p>\n<figure class=\"highlight ts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> vm = <span class=\"built_in\">require</span>(<span class=\"string\">'vm'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> contextObject = &#123; a: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">vm.createContext(contextObject)</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = vm.runInContext(<span class=\"string\">'a += 1; b = 3'</span>, contextObject);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 3 &#123; a: 2, b: 3 &#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"2\">\n<li>vm.runInNewContext(code[, contextObject[, options]])</li>\n</ol>\n<p>给指定的 <code>contextObject</code>（若为 <code>undefined</code>，则会新建一个 <code>contextObject</code> ）提供一个隔离的上下文, 再在此上下文中执行编译的 code，最后返回结果。 运行中的代码无法获取本地作用域。</p>\n<figure class=\"highlight ts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> vm = <span class=\"built_in\">require</span>(<span class=\"string\">'vm'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = vm.runInNewContext(<span class=\"string\">'a += 1; b = 3'</span>, &#123;a: <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// 3 &#123; a: 2, b: 3 &#125;</span></span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"3\">\n<li>vm.runInThisContext(code[, options])</li>\n</ol>\n<p>在当前的 <code>global</code> 对象的上下文中编译并执行 code，最后返回结果。 运行中的代码无法获取本地作用域，但可以获取当前的 <code>global</code> 对象。</p>\n<figure class=\"highlight ts\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global.a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = vm.runInThisContext(<span class=\"string\">'a += 1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></div></figure>\n\n<p><code>vm.runInThisContext()</code> 更像是间接的执行 <code>eval()</code>, 就像 <code>(0,eval)(&#39;code&#39;)</code>。</p>\n<p>参考资料：<br><a href=\"https://segmentfault.com/a/1190000022730362\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000022730362</a><br><a href=\"https://zh.javascript.info/new-function\" target=\"_blank\" rel=\"noopener\">https://zh.javascript.info/new-function</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval</a></p>\n","next":{"title":"《黑客与画家》书摘","link":"post/2021-8-21-book"},"plink":"https://yanoo1497.github.io/post/eval-string/","toc":[{"title":"现存的几种方案","id":"现存的几种方案","index":"1","children":[{"title":"new Function","id":"new-Function","index":"1.1"},{"title":"eval","id":"eval","index":"1.2"},{"title":"通过 node 的核心模块 vm 来实现","id":"通过-node-的核心模块-vm-来实现","index":"1.3"}]}]}