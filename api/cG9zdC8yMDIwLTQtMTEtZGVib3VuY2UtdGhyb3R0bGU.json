{"title":"防抖节流函数实现","date":"2020-04-11T01:20:41.000Z","link":"post/2020-4-11-debounce-throttle","tags":["javascript"],"updated":"2021-06-12T10:38:29.438Z","content":"<blockquote>\n<p>参考文章</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5cfe66fa6fb9a07ee1691ddb\" target=\"_blank\" rel=\"noopener\">深入浅出防抖函数 debounce</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"noopener\">JavaScript专题之跟着underscore学防抖</a></li>\n<li><a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5\" target=\"_blank\" rel=\"noopener\">什么是防抖和节流？有什么区别？如何实现？</a></li>\n<li><a href=\"https://github.com/pekonchan/Blog/issues/14\" target=\"_blank\" rel=\"noopener\">别只掌握基础的防抖和节流了</a></li>\n</ul>\n</blockquote>\n<p>在前端开发中会遇到一些频繁的事件触发，比如：</p>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span> 的 resize、scroll</span><br><span class=\"line\">mousedown、mousemove</span><br><span class=\"line\">keyup、keydown</span><br><span class=\"line\">input</span><br></pre></td></tr></table></div></figure>\n\n<p>这些处理函数如果在没有任何处理措施的情况下，会非常频繁的触发事件，而事件处理的逻辑如果较为复杂大概率上回造成<code>页面卡顿</code>现象。在这些事件的处理上，合理的使用防抖、节流函数是提高性能的不二选择。</p>\n<h2 id=\"防抖函数（debounce）\">防抖函数（debounce）<a href=\"post/2020-4-11-debounce-throttle#防抖函数（debounce）\"></a></h2><p>网上查到的概念也会有很多种，这里列举了不同的描述帮助理解：</p>\n<ul>\n<li>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。</li>\n<li>某个函数在某段时间内，无论触发了多少次回调，都只执行<strong>最后一次</strong>。</li>\n<li>指定时间内，方法只能执行一次。而这个时间的计算，是从<strong>最后一次触发监听事件</strong>开始算起。</li>\n<li>一般表现为，在<strong>一段连续触发的事件中，最终会转化为一次方法执行</strong>，就像防止抖动一样，你做一个事，防止你手抖不小心重复干了。</li>\n</ul>\n<h3 id=\"一些常见的实现\">一些常见的实现<a href=\"post/2020-4-11-debounce-throttle#一些常见的实现\"></a></h3><h4 id=\"高程中的经典代码\">高程中的经典代码<a href=\"post/2020-4-11-debounce-throttle#高程中的经典代码\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, ...arg</span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(method.tId);</span><br><span class=\"line\">    method.tId = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        method.call(...arg);</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h4 id=\"简单的利用-requestAnimationFrame-实现的防抖函数\">简单的利用 requestAnimationFrame 实现的防抖函数<a href=\"post/2020-4-11-debounce-throttle#简单的利用-requestAnimationFrame-实现的防抖函数\"></a></h4><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> t;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        t &amp;&amp; cancelAnimationFrame(t);</span><br><span class=\"line\">        t = requestAnimationFrame(func);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h4 id=\"防抖函数的工厂函数\">防抖函数的工厂函数<a href=\"post/2020-4-11-debounce-throttle#防抖函数的工厂函数\"></a></h4><h5 id=\"普通版\">普通版<a href=\"post/2020-4-11-debounce-throttle#普通版\"></a></h5><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            func.apply(context, ...args)</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h5 id=\"加强版\">加强版<a href=\"post/2020-4-11-debounce-throttle#加强版\"></a></h5><figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 防抖函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; fn - 实际要执行的函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; wait - 规定延迟执行时间间隔，单位毫秒，初始化 16.7 ms（一帧）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Boolean&#125; immediate - 是否立即执行，true 为立即执行，立即执行指触发监听事件是先执行</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Function&#125; 经过防抖处理后的要执行的函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait = <span class=\"number\">16.7</span>, immediate = false</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'debounce 的第一个参数请传入函数'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timerId = <span class=\"literal\">null</span>; <span class=\"comment\">// 记录定时器 id</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 防抖后的执行函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounced</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        timerId &amp;&amp; clearTimeout(timerId);</span><br><span class=\"line\">        <span class=\"comment\">// 如果是立即执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果已经过了规定时间，则执行函数 或 第一次触发监听事件</span></span><br><span class=\"line\">            !timerId &amp;&amp; fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            <span class=\"comment\">// 规定时间后情况定时器 id，表明到达了规定时间</span></span><br><span class=\"line\">            timerId = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                timerId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 延后执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 只有到达了规定时间后才会执行 fn 函数</span></span><br><span class=\"line\">            timerId = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">                timerId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 手动取消该次设定的防抖时间，取消后当成是“第一次触发”一样</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cancel</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        clearTimeout(timerId);</span><br><span class=\"line\">        timerId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"实现一些细节点\">实现一些细节点<a href=\"post/2020-4-11-debounce-throttle#实现一些细节点\"></a></h3><ul>\n<li>间隔一段时间触发一次不一定要用 setTimeout, setTimeout 的时间间隔不可靠，可以使用具体时间戳自己计算间隔；</li>\n<li>如果要设计成通用工具函数，封装成工厂函数更加合适，需要注意 this 指向问题；</li>\n</ul>\n<p>应用场景：<br>主要应用于对首次调用没有明确需要执行，但对最后一次调用要求较高的场景。<br>例如：</p>\n<ul>\n<li>search 搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>\n<li>window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>\n</ul>\n<h2 id=\"节流函数（throttle）\">节流函数（throttle）<a href=\"post/2020-4-11-debounce-throttle#节流函数（throttle）\"></a></h2><p>这里列举了不同的描述帮助理解</p>\n<ul>\n<li>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次（单位时间内的第一次）生效。</li>\n<li>可以保证<strong>第一次调用</strong>的一定会被执行，但无法保证最后一次调用的有效。</li>\n<li>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率；</li>\n<li>指定时间内，方法只能执行一次。而这个时间的计算，是从上次执行方法开始算起。</li>\n</ul>\n<figure class=\"highlight js\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 节流函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; fn - 实际要执行的函数，对其进行节流处理</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; wait - 规定的执行时间间隔，单位毫秒，初始化 16.7 ms（一帧）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Object&#125; option - 用于设置节流的函数的触发时机，</span></span><br><span class=\"line\"><span class=\"comment\"> *                        - 默认是 &#123;leading: true, trailing: true&#125;，表示第一次触发监听事件马上执行，停止后最后也执行一次</span></span><br><span class=\"line\"><span class=\"comment\"> *                        - leading 为 false 时，表示第一次触发不马上执行</span></span><br><span class=\"line\"><span class=\"comment\"> *                        - trailing 为 false 时，表示最后停止触发后不执行</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Function&#125; 返回经过节流处理后的函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, wait = <span class=\"number\">16.7</span>, option = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'throttle 的第一个参数请传入函数'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timerId = <span class=\"literal\">null</span>; <span class=\"comment\">// 用于记录定时器的 id</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastTime = <span class=\"number\">0</span>; <span class=\"comment\">// 上次触发 fn 的时间戳</span></span><br><span class=\"line\">    option = <span class=\"built_in\">Object</span>.assign(&#123;</span><br><span class=\"line\">        leading: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        trailing: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;, option); <span class=\"comment\">// 初始化默认值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (option.leading === <span class=\"literal\">false</span> &amp;&amp; option.trailing === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'option 的 leading 和 trailing 不能同时为 false'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 节流后的执行函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttled</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 获取当前时间</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有上次触发执行时间（即第一次运行），以及 leading 设置为 false</span></span><br><span class=\"line\">        !lastTime &amp;&amp; option.leading === <span class=\"literal\">false</span> &amp;&amp; (lastTime = now);</span><br><span class=\"line\">        <span class=\"comment\">// 距离到达规定的 wait 时间剩余时间</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> remainingTime = wait - (now - lastTime);</span><br><span class=\"line\">        <span class=\"comment\">// 条件①：如果到达了规定的间隔时间或用户自己设定了系统时间导致的不合理时间差，则立刻执行一次触发函数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainingTime &lt;= <span class=\"number\">0</span> || remainingTime &gt; wait) &#123;</span><br><span class=\"line\">            fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            lastTime = now;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timerId) &#123;</span><br><span class=\"line\">                clearTimeout(timerId);</span><br><span class=\"line\">                timerId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 条件②：如果未达到规定时间，以及要求停止后延迟执行（trailing=false）</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!timerId &amp;&amp; option.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">            timerId = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                timerId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">                lastTime = option.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">            &#125;, remainingTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 手动提前终止节流时间，恢复初始状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cancel</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        clearTimeout(timerId);</span><br><span class=\"line\">        timerId = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        lastTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    throttled.cancel = cancel;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"throttle-的选项配置说明\">throttle 的选项配置说明<a href=\"post/2020-4-11-debounce-throttle#throttle-的选项配置说明\"></a></h3><ul>\n<li>在 <code>{leading: true, trailing: true}</code> 下，为大多数正常需求所用。在这种情况下，条件①只- 有在第一次触发，以及后续超过规定间隔时间后的第一次触发，才会走到该流程下；其余都是在条件②下触发fn。</li>\n<li>在 <code>{leading: false}</code> 下，都是在条件②下触发fn，走不到条件①下的。</li>\n<li>在 <code>{trailing: false}</code> 下，都是在条件①下触发fn，走不到条件②下的。</li>\n</ul>\n<h3 id=\"应用场景\">应用场景<a href=\"post/2020-4-11-debounce-throttle#应用场景\"></a></h3><p>主要应用于对最后一次调用没有明确需要执行，但对首次调用要求较高的场景。</p>\n<p>例如：<br>表单提交按钮要避免用户多次点击发送多次消息。</p>\n<h2 id=\"防抖节流在实际应用中的差异\">防抖节流在实际应用中的差异<a href=\"post/2020-4-11-debounce-throttle#防抖节流在实际应用中的差异\"></a></h2><p>可以观察 <a href=\"http://demo.nimius.net/debounce_throttle/\" target=\"_blank\" rel=\"noopener\">http://demo.nimius.net/debounce_throttle/</a> 体验，不过这个只是最基本版本的防抖节流差异，实际上防抖节流函数可以设计成实际应用中需要的样子。如果只是简单场景中的使用，只需要写成最基础的版本即可。</p>\n<hr>\n","prev":{"title":"安装 node C++ 模块的常见问题 \"node.lib:fatal error LNK1127\"","link":"post/20-08-26-nodegyp"},"next":{"title":"编写一个函数计算多个数组的交集","link":"post/intersect"},"plink":"https://yanoo1497.github.io/post/2020-4-11-debounce-throttle/","toc":[{"title":"防抖函数（debounce）","id":"防抖函数（debounce）","index":"1","children":[{"title":"一些常见的实现","id":"一些常见的实现","index":"1.1","children":[{"title":"高程中的经典代码","id":"高程中的经典代码","index":"1.1.1"},{"title":"简单的利用 requestAnimationFrame 实现的防抖函数","id":"简单的利用-requestAnimationFrame-实现的防抖函数","index":"1.1.2"},{"title":"防抖函数的工厂函数","id":"防抖函数的工厂函数","index":"1.1.3"}]},{"title":"实现一些细节点","id":"实现一些细节点","index":"1.2"}]},{"title":"节流函数（throttle）","id":"节流函数（throttle）","index":"2","children":[{"title":"throttle 的选项配置说明","id":"throttle-的选项配置说明","index":"2.1"},{"title":"应用场景","id":"应用场景","index":"2.2"}]},{"title":"防抖节流在实际应用中的差异","id":"防抖节流在实际应用中的差异","index":"3"}]}