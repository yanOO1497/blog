{"title":"《TypeScript Deep Dive》（一）——English Learning Weekly","date":"2019-09-22T04:22:54.000Z","link":"post/2019-9-21-word","tags":["weekly"],"categories":["weekly"],"updated":"2021-06-12T10:30:19.517Z","content":"<blockquote>\n<p><a href=\"https://github.com/basarat/typescript-book/\" target=\"_blank\" rel=\"noopener\">《TypeScript Deep Dive》</a></p>\n</blockquote>\n<p>This week I read the book named《TypeScript Deep Dive》 in English, I found that there many new words、phrases and perfect sentence for me to learn, so I note it.Maybe I can use some expresstion in my documation some day.Below are those sentences and words:</p>\n<ul>\n<li><p>semantics: 语意</p>\n</li>\n<li><p>cognitive: 认知</p>\n<blockquote>\n<p>ex: n TypeScript because we really want it to be easy for JavaScript developers with a minimum cognitive overload, types are structural.</p>\n</blockquote>\n</li>\n<li><p>valid 有效的</p>\n</li>\n<li><p>specimen 标本、示例</p>\n<blockquote>\n<p>But just as a specimen here is an example of a class:</p>\n</blockquote>\n</li>\n<li><p>syntax 句法语法</p>\n</li>\n<li><p>diagram 图表</p>\n</li>\n<li><p>interpretation 解释</p>\n</li>\n<li><p>portions 部分</p>\n<blockquote>\n<p>TypeScript will try to protect you from <code>portions</code> of JavaScript that never worked (so you don’t need to remember this stuff)</p>\n</blockquote>\n</li>\n<li><p>nonsensical 无厘头的</p>\n<blockquote>\n<p>other things that are <code>nonsensical</code> in JavaScript</p>\n</blockquote>\n</li>\n<li><p>Essentially 实际上</p>\n</li>\n<li><p>pragmatic 务实的</p>\n<blockquote>\n<p>That said TypeScript is very <code>pragmatic</code> about the fact that you do write JavaScript so there are some things about JavaScript that you still need to know in order to not be caught off-guard. Let’s discuss them next.</p>\n</blockquote>\n</li>\n<li><p>resilient 弹性的</p>\n</li>\n<li><p>coercion 控制</p>\n<blockquote>\n<p>As JavaScript tries to be resilient against programming errors == tries to do type <code>coercion</code> between two variables e.g. converts a string to a number so that you can compare with a number as shown below:</p>\n</blockquote>\n</li>\n<li><p>mutations 突变、变化</p>\n<blockquote>\n<p>Mutations are across all references</p>\n</blockquote>\n</li>\n<li><p>distinct 不同</p>\n<blockquote>\n<p>baz is a <em>new object</em> distinct from <code>foo</code></p>\n</blockquote>\n</li>\n<li><p>unwinds 展开</p>\n</li>\n<li><p>annotation 注解</p>\n</li>\n<li><p>validity 合法性</p>\n</li>\n<li><p>mindful 细心的</p>\n<blockquote>\n<p>So be <code>mindful</code> of your usage of this. If you want to disconnect this in a class from the calling context use an arrow function, more on that later.</p>\n</blockquote>\n</li>\n<li><p>closure 关闭(js: 闭包)</p>\n<blockquote>\n<p>You can see that the inner function has access to a variable (variableInOuterFunction) from the outer scope. The variables in the outer function have been closed by (or bound in) the inner function. Hence the term <code>closure</code>.</p>\n</blockquote>\n</li>\n<li><p>idiosyncrasies 特质</p>\n<blockquote>\n<p>Whenever you are handling numbers in any programming language you need to be aware of the <code>idiosyncrasies</code> of how the language handles numbers. Here are a few critical pieces of information about numbers in JavaScript that you should be aware of.</p>\n</blockquote>\n</li>\n<li><p>Decimal 十进制</p>\n<blockquote>\n<p>For those familiar with doubles / float in other languages, you would know that binary floating point numbers do not map correctly to <code>Decimal</code> numbers.</p>\n</blockquote>\n</li>\n<li><p>arithmetic 算术的、算法的</p>\n<blockquote>\n<p>Of-course, these special infinity values also show up with <code>arithmetic</code> that requires it e.g.</p>\n</blockquote>\n</li>\n<li><p>manually 手动地</p>\n</li>\n<li><p>clamp 逼近、夹紧</p>\n<blockquote>\n<p>Further intuition: Just like values bigger than Number.MAX_VALUE get clamped to INFINITY, values smaller than Number.MIN_VALUE get clamped to 0.</p>\n</blockquote>\n</li>\n<li><p>i.e. 即</p>\n<blockquote>\n<p>JavaScript has a concept of truthy <code>i.e.</code> things that evaluate like true would in certain positions (e.g. if conditions and the boolean &amp;&amp; || operators).</p>\n</blockquote>\n</li>\n<li><p>handy 方便的</p>\n<blockquote>\n<p>Here’s a <code>handy</code> table for your reference.</p>\n</blockquote>\n</li>\n<li><p>explicit 明确的</p>\n</li>\n<li><p>intent 意图</p>\n<blockquote>\n<p>Quite commonly it helps to be <code>explicit</code> that the intent is to treat the value as a boolean and convert it into a true boolean (one of true|false).</p>\n</blockquote>\n</li>\n<li><p>implement 实现实施</p>\n</li>\n<li><p>dive 潜水 潜入</p>\n<blockquote>\n<p>Here we deep <code>dive</code> into why these features are useful followed by how these features are <code>implemented</code> in TypeScript.</p>\n</blockquote>\n</li>\n<li><p>slated</p>\n</li>\n<li><blockquote>\n<p>Note: Not all of these features are <code>slated</code> for immediate addition to JavaScript but provide great utility to your code organization and <code>maintenance</code>.</p>\n</blockquote>\n</li>\n<li><p>specified 规定</p>\n</li>\n<li><p>implicitly 隐式的</p>\n<blockquote>\n<p>If an access modifier is not specified it is implicitly public as that matches the convenient nature of JavaScript</p>\n</blockquote>\n</li>\n<li><p>significance 意义</p>\n<blockquote>\n<p>Note that at runtime (in the generated JS) these have no <code>significance</code> but will give you compile time errors if you use them incorrectly.</p>\n</blockquote>\n</li>\n<li><p>invoked</p>\n</li>\n<li><p>functionality</p>\n<blockquote>\n<p>Having an abstract modifier primarily means that such <code>functionality</code> cannot be directly <code>invoked</code> and a child class must provide the functionality.</p>\n</blockquote>\n</li>\n<li><p>shorthand 速记、缩写</p>\n<blockquote>\n<p>is such a common pattern that TypeScript provides a <code>shorthand</code> where you can prefix the member with an access modifier and it is automatically declared on the class and copied from the constructor. </p>\n</blockquote>\n</li>\n<li><p>nifty 俏皮的</p>\n<blockquote>\n<p>This is a <code>nifty</code> feature supported by TypeScript (from ES7 actually).</p>\n</blockquote>\n</li>\n<li><p>consistently 始终如一</p>\n<blockquote>\n<p>Lovingly called the fat arrow (because -&gt; is a thin arrow and =&gt; is a fat arrow)</p>\n</blockquote>\n</li>\n<li><p>syntax 句法</p>\n</li>\n<li><p>demonstrate 验证证明</p>\n<blockquote>\n<p>The same example is <code>demonstrated</code> with let:<br>Since we mentioned it, we’d like to <code>demonstrate</code> that functions create a new variable scope in JavaScript. Consider the following:</p>\n</blockquote>\n</li>\n<li><p>hence 于是</p>\n<blockquote>\n<p>Here the functions close over (<code>hence</code> called a closure)</p>\n</blockquote>\n</li>\n<li><p>vast 大</p>\n<blockquote>\n<p>let is extremely useful to have for the vast majority of code. </p>\n</blockquote>\n</li>\n<li><p>immutable 一层不变的</p>\n<blockquote>\n<p>const is a very welcomed addition offered by ES6 / TypeScript. It allows you to be immutable with variables.</p>\n</blockquote>\n</li>\n<li><p>cumbersome 笨重、笨拙</p>\n<blockquote>\n<p>Without the awesome structuring support built into JavaScript, creating new objects on the fly would indeed be very cumbersome. Destructuring brings the same level of convenience to getting data out of a structure.</p>\n</blockquote>\n</li>\n</ul>\n","prev":{"title":"周记(2019-9-16 —— 2019-9-22)","link":"post/2019-9-22-notes"},"next":{"title":"关于 typescript 学习手记（三）类型推断","link":"post/typescript"},"plink":"https://yanoo1497.github.io/post/2019-9-21-word/"}